This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.go
- Files matching these patterns are excluded: node_modules, **/node_modules, **/.venv/**, **/venv/**, **/yarn.lock, **/*.md, internal/widgets/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
.github/ISSUE_TEMPLATE/
.github/workflows/
docs/
docs/images/
docs/images/themes/
internal/
internal/app/
internal/auth/
internal/common/
internal/loader/
internal/models/
internal/web/
internal/web/static/
internal/web/static/css/
internal/web/static/fonts/
internal/web/static/js/
internal/web/templates/
internal/widgets/
pkg/
pkg/sysinfo/
static/
internal/app/cli.go
internal/app/diagnose.go
internal/app/glance.go
internal/app/main.go
internal/app/theme.go
internal/auth/auth_test.go
internal/auth/auth.go
internal/common/common.go
internal/loader/config.go
internal/models/config.go
internal/models/fields.go
internal/models/map.go
internal/models/theme.go
internal/models/widget.go
internal/web/embed.go
internal/web/templates.go
main.go
pkg/sysinfo/sysinfo.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="internal/app/theme.go">
package app
import (
	"net/http"
	"time"
	"github.com/limpdev/gander/internal/common"
)
func (a *application) handleThemeChangeRequest(w http.ResponseWriter, r *http.Request) {
	themeKey := r.PathValue("key")
	properties, exists := a.Config.Theme.Presets.Get(themeKey)
	if !exists && themeKey != "default" {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	if themeKey == "default" {
		properties = &a.Config.Theme.ThemeProperties
	}
	http.SetCookie(w, &http.Cookie{
		Name:     "theme",
		Value:    themeKey,
		Path:     a.Config.Server.BaseURL + "/",
		SameSite: http.SameSiteLaxMode,
		Expires:  time.Now().Add(2 * 365 * 24 * time.Hour),
	})
	w.Header().Set("Content-Type", "text/css")
	w.Header().Set("X-Scheme", common.Ternary(properties.Light, "light", "dark"))
	w.Write([]byte(properties.CSS))
}
</file>

<file path="internal/common/common.go">
package common
import (
	"bytes"
	"fmt"
	"html/template"
	"math"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"
	"github.com/limpdev/gander/internal/web"
	"golang.org/x/text/language"
	"golang.org/x/text/message"
)
func FileServerWithCache(fs http.FileSystem, cacheDuration time.Duration) http.Handler {
	server := http.FileServer(fs)
	cacheControlValue := fmt.Sprintf("public, max-age=%d", int(cacheDuration.Seconds()))
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// TODO: fix always setting cache control even if the file doesn't exist
		w.Header().Set("Cache-Control", cacheControlValue)
		server.ServeHTTP(w, r)
	})
}
var BuildVersion = "dev"
const DefaultClientTimeout = 5 * time.Second
var (
	SequentialWhitespacePattern        = regexp.MustCompile(`\s+`)
	WhitespaceAtBeginningOfLinePattern = regexp.MustCompile(`(?m)^\s+`)
)
func PercentChange(current, previous float64) float64 {
	if previous == 0 {
		if current == 0 {
			return 0 // 0% change if both are 0
		}
		return 100 // 100% increase if going from 0 to something
	}
	return (current/previous - 1) * 100
}
func ExtractDomainFromUrl(u string) string {
	if u == "" {
		return ""
	}
	parsed, err := url.Parse(u)
	if err != nil {
		return ""
	}
	return strings.TrimPrefix(strings.ToLower(parsed.Host), "www.")
}
func SvgPolylineCoordsFromYValues(width float64, height float64, values []float64) string {
	if len(values) < 2 {
		return ""
	}
	verticalPadding := height * 0.02
	height -= verticalPadding * 2
	coordinates := make([]string, len(values))
	distanceBetweenPoints := width / float64(len(values)-1)
	min := slices.Min(values)
	max := slices.Max(values)
	for i := range values {
		coordinates[i] = fmt.Sprintf(
			"%.2f,%.2f",
			float64(i)*distanceBetweenPoints,
			((max-values[i])/(max-min))*height+verticalPadding,
		)
	}
	return strings.Join(coordinates, " ")
}
func MaybeCopySliceWithoutZeroValues[T int | float64](values []T) []T {
	if len(values) == 0 {
		return values
	}
	for i := range values {
		if values[i] != 0 {
			continue
		}
		c := make([]T, 0, len(values)-1)
		for i := range values {
			if values[i] != 0 {
				c = append(c, values[i])
			}
		}
		return c
	}
	return values
}
var urlSchemePattern = regexp.MustCompile(`^[a-z]+:\/\/`)
func StripURLScheme(url string) string {
	return urlSchemePattern.ReplaceAllString(url, "")
}
func IsRunningInsideDockerContainer() bool {
	_, err := os.Stat("/.dockerenv")
	return err == nil
}
func PrefixStringLines(prefix string, s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		lines[i] = prefix + line
	}
	return strings.Join(lines, "\n")
}
func LimitStringLength(s string, max int) (string, bool) {
	asRunes := []rune(s)
	if len(asRunes) > max {
		return string(asRunes[:max]), true
	}
	return s, false
}
func ParseRFC3339Time(t string) time.Time {
	parsed, err := time.Parse(time.RFC3339, t)
	if err != nil {
		return time.Now()
	}
	return parsed
}
func NormalizeVersionFormat(version string) string {
	version = strings.ToLower(strings.TrimSpace(version))
	if len(version) > 0 && version[0] != 'v' {
		return "v" + version
	}
	return version
}
func TitleToSlug(s string) string {
	s = strings.ToLower(s)
	s = SequentialWhitespacePattern.ReplaceAllString(s, "-")
	s = strings.Trim(s, "-")
	return s
}
func ExecuteTemplateToString(t *template.Template, data any) (string, error) {
	var b bytes.Buffer
	err := t.Execute(&b, data)
	if err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}
	return b.String(), nil
}
func StringToBool(s string) bool {
	return s == "true" || s == "yes"
}
func ItemAtIndexOrDefault[T any](items []T, index int, def T) T {
	if index >= len(items) {
		return def
	}
	return items[index]
}
func Ternary[T any](condition bool, a, b T) T {
	if condition {
		return a
	}
	return b
}
func HslToHex(h, s, l float64) string {
	s /= 100.0
	l /= 100.0
	var r, g, b float64
	if s == 0 {
		r, g, b = l, l, l
	} else {
		hueToRgb := func(p, q, t float64) float64 {
			if t < 0 {
				t += 1
			}
			if t > 1 {
				t -= 1
			}
			if t < 1.0/6.0 {
				return p + (q-p)*6.0*t
			}
			if t < 1.0/2.0 {
				return q
			}
			if t < 2.0/3.0 {
				return p + (q-p)*(2.0/3.0-t)*6.0
			}
			return p
		}
		q := 0.0
		if l < 0.5 {
			q = l * (1 + s)
		} else {
			q = l + s - l*s
		}
		p := 2*l - q
		h /= 360.0
		r = hueToRgb(p, q, h+1.0/3.0)
		g = hueToRgb(p, q, h)
		b = hueToRgb(p, q, h-1.0/3.0)
	}
	ir := int(math.Round(r * 255.0))
	ig := int(math.Round(g * 255.0))
	ib := int(math.Round(b * 255.0))
	ir = int(math.Max(0, math.Min(255, float64(ir))))
	ig = int(math.Max(0, math.Min(255, float64(ig))))
	ib = int(math.Max(0, math.Min(255, float64(ib))))
	return fmt.Sprintf("#%02x%02x%02x", ir, ig, ib)
}
func MustParseTemplate(primary string, dependencies ...string) *template.Template {
	t, err := template.New(primary).
		Funcs(globalTemplateFunctions).
		ParseFS(web.TemplateFS, append([]string{primary}, dependencies...)...)
	if err != nil {
		panic(err)
	}
	return t
}
func formatApproxNumber(count int) string {
	if count < 1_000 {
		return strconv.Itoa(count)
	}
	if count < 10_000 {
		return strconv.FormatFloat(float64(count)/1_000, 'f', 1, 64) + "k"
	}
	if count < 1_000_000 {
		return strconv.Itoa(count/1_000) + "k"
	}
	return strconv.FormatFloat(float64(count)/1_000_000, 'f', 1, 64) + "m"
}
func dynamicRelativeTimeAttrs(t interface{ Unix() int64 }) template.HTMLAttr {
	return template.HTMLAttr(`data-dynamic-relative-time="` + strconv.FormatInt(t.Unix(), 10) + `"`)
}
var intl = message.NewPrinter(language.English)
var globalTemplateFunctions = template.FuncMap{
	"formatApproxNumber": formatApproxNumber,
	"formatNumber":       intl.Sprint,
	"safeCSS": func(str string) template.CSS {
		return template.CSS(str)
	},
	"safeURL": func(str string) template.URL {
		return template.URL(str)
	},
	"safeHTML": func(str string) template.HTML {
		return template.HTML(str)
	},
	"absInt": func(i int) int {
		return int(math.Abs(float64(i)))
	},
	"formatPrice": func(price float64) string {
		return intl.Sprintf("%.2f", price)
	},
	"formatPriceWithPrecision": func(precision int, price float64) string {
		return intl.Sprintf("%."+strconv.Itoa(precision)+"f", price)
	},
	"dynamicRelativeTimeAttrs": dynamicRelativeTimeAttrs,
	"formatServerMegabytes": func(mb uint64) template.HTML {
		var value string
		var label string
		if mb < 1_000 {
			value = strconv.FormatUint(mb, 10)
			label = "MB"
		} else if mb < 1_000_000 {
			if mb < 10_000 {
				value = fmt.Sprintf("%.1f", float64(mb)/1_000)
			} else {
				value = strconv.FormatUint(mb/1_000, 10)
			}
			label = "GB"
		} else {
			value = fmt.Sprintf("%.1f", float64(mb)/1_000_000)
			label = "TB"
		}
		return template.HTML(value + ` <span class="color-base size-h5">` + label + `</span>`)
	},
}
</file>

<file path="internal/loader/config.go">
package loader
import (
	"bytes"
	"errors"
	"fmt"
	"log"
	"maps"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"
	"github.com/fsnotify/fsnotify"
	"github.com/limpdev/gander/internal/common"
	"github.com/limpdev/gander/internal/models"
	"gopkg.in/yaml.v3"
)
const CONFIG_INCLUDE_RECURSION_DEPTH_LIMIT = 20
const (
	configVarTypeEnv         = "env"
	configVarTypeSecret      = "secret"
	configVarTypeFileFromEnv = "readFileFromEnv"
)
func NewConfigFromYAML(contents []byte) (*models.Config, error) {
	contents, err := ParseConfigVariables(contents)
	if err != nil {
		return nil, err
	}
	config := &models.Config{}
	config.Server.Port = 8080
	err = yaml.Unmarshal(contents, config)
	if err != nil {
		return nil, err
	}
	if err = IsConfigStateValid(config); err != nil {
		return nil, err
	}
	// Initialize widgets
	// We need to iterate over Pages, then HeadWidgets and Column Widgets
	for p := range config.Pages {
		for w := range config.Pages[p].HeadWidgets {
			if err := config.Pages[p].HeadWidgets[w].Initialize(); err != nil {
				return nil, FormatWidgetInitError(err, config.Pages[p].HeadWidgets[w])
			}
		}
		for c := range config.Pages[p].Columns {
			for w := range config.Pages[p].Columns[c].Widgets {
				if err := config.Pages[p].Columns[c].Widgets[w].Initialize(); err != nil {
					return nil, FormatWidgetInitError(err, config.Pages[p].Columns[c].Widgets[w])
				}
			}
		}
	}
	// Initialize theme
	// Access via config.Theme.ThemeProperties (embedded)
	if err := config.Theme.ThemeProperties.Initialize(); err != nil {
		return nil, fmt.Errorf("initializing theme: %w", err)
	}
	// Initialize theme presets
	// Use Items iterator from OrderedYAMLMap
	for _, preset := range config.Theme.Presets.Items() {
		// preset is a *models.ThemeProperties
		if err := preset.Initialize(); err != nil {
			return nil, fmt.Errorf("initializing theme preset: %w", err)
		}
	}
	return config, nil
}
var (
	envVariableNamePattern = regexp.MustCompile(`^[A-Z0-9_]+$`)
	configVariablePattern  = regexp.MustCompile(`(^|.)\$\{(?:([a-zA-Z]+):)?([a-zA-Z0-9_-]+)\}`)
)
func ParseConfigVariables(contents []byte) ([]byte, error) {
	var err error
	replaced := configVariablePattern.ReplaceAllFunc(contents, func(match []byte) []byte {
		if err != nil {
			return nil
		}
		groups := configVariablePattern.FindSubmatch(match)
		if len(groups) != 4 {
			return match
		}
		prefix := string(groups[1])
		if prefix == `\` {
			if len(match) >= 2 {
				return match[1:]
			} else {
				return nil
			}
		}
		typeAsString, variableName := string(groups[2]), string(groups[3])
		variableType := common.Ternary(typeAsString == "", configVarTypeEnv, typeAsString)
		parsedValue, returnOriginal, localErr := ParseConfigVariableOfType(variableType, variableName)
		if localErr != nil {
			err = fmt.Errorf("parsing variable: %v", localErr)
			return nil
		}
		if returnOriginal {
			return match
		}
		return []byte(prefix + parsedValue)
	})
	if err != nil {
		return nil, err
	}
	return replaced, nil
}
func ParseConfigVariableOfType(variableType, variableName string) (string, bool, error) {
	switch variableType {
	case configVarTypeEnv:
		if !envVariableNamePattern.MatchString(variableName) {
			return "", true, nil
		}
		v, found := os.LookupEnv(variableName)
		if !found {
			return "", false, fmt.Errorf("environment variable %s not found", variableName)
		}
		return v, false, nil
	case configVarTypeSecret:
		secretPath := filepath.Join("/run/secrets", variableName)
		secret, err := os.ReadFile(secretPath)
		if err != nil {
			return "", false, fmt.Errorf("reading secret file: %v", err)
		}
		return strings.TrimSpace(string(secret)), false, nil
	case configVarTypeFileFromEnv:
		if !envVariableNamePattern.MatchString(variableName) {
			return "", true, nil
		}
		filePath, found := os.LookupEnv(variableName)
		if !found {
			return "", false, fmt.Errorf("readFileFromEnv: environment variable %s not found", variableName)
		}
		if !filepath.IsAbs(filePath) {
			return "", false, fmt.Errorf("readFileFromEnv: file path %s is not absolute", filePath)
		}
		fileContents, err := os.ReadFile(filePath)
		if err != nil {
			return "", false, fmt.Errorf("readFileFromEnv: reading file from %s: %v", variableName, err)
		}
		return strings.TrimSpace(string(fileContents)), false, nil
	default:
		return "", true, nil
	}
}
func FormatWidgetInitError(err error, w models.Widget) error {
	return fmt.Errorf("%s widget: %v", w.GetType(), err)
}
var configIncludePattern = regexp.MustCompile(`(?m)^([ \t]*)(?:-[ \t]*)?(?:!|\$)include:[ \t]*(.+)$`)
func ParseYAMLIncludes(mainFilePath string) ([]byte, map[string]struct{}, error) {
	return RecursiveParseYAMLIncludes(mainFilePath, nil, 0)
}
func RecursiveParseYAMLIncludes(mainFilePath string, includes map[string]struct{}, depth int) ([]byte, map[string]struct{}, error) {
	if depth > CONFIG_INCLUDE_RECURSION_DEPTH_LIMIT {
		return nil, nil, fmt.Errorf("recursion depth limit of %d reached", CONFIG_INCLUDE_RECURSION_DEPTH_LIMIT)
	}
	mainFileContents, err := os.ReadFile(mainFilePath)
	if err != nil {
		return nil, nil, fmt.Errorf("reading %s: %w", mainFilePath, err)
	}
	mainFileAbsPath, err := filepath.Abs(mainFilePath)
	if err != nil {
		return nil, nil, fmt.Errorf("getting absolute path of %s: %w", mainFilePath, err)
	}
	mainFileDir := filepath.Dir(mainFileAbsPath)
	if includes == nil {
		includes = make(map[string]struct{})
	}
	var includesLastErr error
	mainFileContents = configIncludePattern.ReplaceAllFunc(mainFileContents, func(match []byte) []byte {
		if includesLastErr != nil {
			return nil
		}
		matches := configIncludePattern.FindSubmatch(match)
		if len(matches) != 3 {
			includesLastErr = fmt.Errorf("invalid include match: %v", matches)
			return nil
		}
		indent := string(matches[1])
		includeFilePath := strings.TrimSpace(string(matches[2]))
		if !filepath.IsAbs(includeFilePath) {
			includeFilePath = filepath.Join(mainFileDir, includeFilePath)
		}
		var fileContents []byte
		var err error
		includes[includeFilePath] = struct{}{}
		fileContents, includes, err = RecursiveParseYAMLIncludes(includeFilePath, includes, depth+1)
		if err != nil {
			includesLastErr = err
			return nil
		}
		return []byte(common.PrefixStringLines(indent, string(fileContents)))
	})
	if includesLastErr != nil {
		return nil, nil, includesLastErr
	}
	return mainFileContents, includes, nil
}
func ConfigFilesWatcher(
	mainFilePath string,
	lastContents []byte,
	lastIncludes map[string]struct{},
	onChange func(newContents []byte),
	onErr func(error),
) (func() error, error) {
	mainFileAbsPath, err := filepath.Abs(mainFilePath)
	if err != nil {
		return nil, fmt.Errorf("getting absolute path of main file: %w", err)
	}
	// TODO: refactor, flaky
	lastIncludes[mainFileAbsPath] = struct{}{}
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, fmt.Errorf("creating watcher: %w", err)
	}
	updateWatchedFiles := func(previousWatched map[string]struct{}, newWatched map[string]struct{}) {
		for filePath := range previousWatched {
			if _, ok := newWatched[filePath]; !ok {
				watcher.Remove(filePath)
			}
		}
		for filePath := range newWatched {
			if _, ok := previousWatched[filePath]; !ok {
				if err := watcher.Add(filePath); err != nil {
					log.Printf(
						"Could not add file to watcher, changes to this file will not trigger a reload. path: %s, error: %v",
						filePath, err,
					)
				}
			}
		}
	}
	updateWatchedFiles(nil, lastIncludes)
	// needed for lastContents and lastIncludes because they get updated in multiple goroutines
	mu := sync.Mutex{}
	parseAndCompareBeforeCallback := func() {
		currentContents, currentIncludes, err := ParseYAMLIncludes(mainFilePath)
		if err != nil {
			onErr(fmt.Errorf("parsing main file contents for comparison: %w", err))
			return
		}
		// TODO: refactor, flaky
		currentIncludes[mainFileAbsPath] = struct{}{}
		mu.Lock()
		defer mu.Unlock()
		if !maps.Equal(currentIncludes, lastIncludes) {
			updateWatchedFiles(lastIncludes, currentIncludes)
			lastIncludes = currentIncludes
		}
		if !bytes.Equal(lastContents, currentContents) {
			lastContents = currentContents
			onChange(currentContents)
		}
	}
	const debounceDuration = 500 * time.Millisecond
	var debounceTimer *time.Timer
	debouncedParseAndCompareBeforeCallback := func() {
		if debounceTimer != nil {
			debounceTimer.Stop()
			debounceTimer.Reset(debounceDuration)
		} else {
			debounceTimer = time.AfterFunc(debounceDuration, parseAndCompareBeforeCallback)
		}
	}
	deleteLastInclude := func(filePath string) {
		mu.Lock()
		defer mu.Unlock()
		fileAbsPath, _ := filepath.Abs(filePath)
		delete(lastIncludes, fileAbsPath)
	}
	go func() {
		for {
			select {
			case event, isOpen := <-watcher.Events:
				if !isOpen {
					return
				}
				if event.Has(fsnotify.Write) {
					debouncedParseAndCompareBeforeCallback()
				} else if event.Has(fsnotify.Rename) {
					// on linux the file will no longer be watched after a rename, on windows
					// it will continue to be watched with the new name but we have no access to
					// the new name in this event in order to stop watching it manually and match the
					// behavior in linux, may lead to weird unintended behaviors on windows as we're
					// only handling renames from linux's perspective
					// see https://github.com/fsnotify/fsnotify/issues/255
					// remove the old file from our manually tracked includes, calling
					// debouncedParseAndCompareBeforeCallback will re-add it if it's still
					// required after it triggers
					deleteLastInclude(event.Name)
					// wait for file to maybe get created again
					// see https://github.com/glanceapp/glance/pull/358
					for range 10 {
						if _, err := os.Stat(event.Name); err == nil {
							break
						}
						time.Sleep(200 * time.Millisecond)
					}
					debouncedParseAndCompareBeforeCallback()
				} else if event.Has(fsnotify.Remove) {
					deleteLastInclude(event.Name)
					debouncedParseAndCompareBeforeCallback()
				}
			case err, isOpen := <-watcher.Errors:
				if !isOpen {
					return
				}
				onErr(fmt.Errorf("watcher error: %w", err))
			}
		}
	}()
	onChange(lastContents)
	return func() error {
		if debounceTimer != nil {
			debounceTimer.Stop()
		}
		return watcher.Close()
	}, nil
}
func IsConfigStateValid(config *models.Config) error {
	if len(config.Pages) == 0 {
		return fmt.Errorf("no pages configured")
	}
	if len(config.Auth.Users) > 0 && config.Auth.SecretKey == "" {
		return fmt.Errorf("secret-key must be set when users are configured")
	}
	for username := range config.Auth.Users {
		if username == "" {
			return fmt.Errorf("user has no name")
		}
		if len(username) < 3 {
			return errors.New("usernames must be at least 3 characters")
		}
		user := config.Auth.Users[username]
		if user.Password == "" {
			if user.PasswordHashString == "" {
				return fmt.Errorf("user %s must have a password or a password-hash set", username)
			}
		} else if len(user.Password) < 6 {
			return fmt.Errorf("the password for %s must be at least 6 characters", username)
		}
	}
	if config.Server.AssetsPath != "" {
		if _, err := os.Stat(config.Server.AssetsPath); os.IsNotExist(err) {
			return fmt.Errorf("assets directory does not exist: %s", config.Server.AssetsPath)
		}
	}
	for i := range config.Pages {
		page := &config.Pages[i]
		if page.Title == "" {
			return fmt.Errorf("page %d has no name", i+1)
		}
		if page.Width != "" && (page.Width != "wide" && page.Width != "slim" && page.Width != "default") {
			return fmt.Errorf("page %d: width can only be either wide or slim", i+1)
		}
		if page.DesktopNavigationWidth != "" {
			if page.DesktopNavigationWidth != "wide" && page.DesktopNavigationWidth != "slim" && page.DesktopNavigationWidth != "default" {
				return fmt.Errorf("page %d: desktop-navigation-width can only be either wide or slim", i+1)
			}
		}
		if len(page.Columns) == 0 {
			return fmt.Errorf("page %d has no columns", i+1)
		}
		if page.Width == "slim" {
			if len(page.Columns) > 2 {
				return fmt.Errorf("page %d is slim and cannot have more than 2 columns", i+1)
			}
		} else {
			if len(page.Columns) > 3 {
				return fmt.Errorf("page %d has more than 3 columns", i+1)
			}
		}
		columnSizesCount := make(map[string]int)
		for j := range page.Columns {
			column := &page.Columns[j]
			if column.Size != "small" && column.Size != "full" {
				return fmt.Errorf("column %d of page %d: size can only be either small or full", j+1, i+1)
			}
			columnSizesCount[page.Columns[j].Size]++
		}
		full := columnSizesCount["full"]
		if full > 2 || full == 0 {
			return fmt.Errorf("page %d must have either 1 or 2 full width columns", i+1)
		}
	}
	return nil
}
</file>

<file path="internal/models/config.go">
package models
import (
	"html/template"
	"sync"
)
type Config struct {
	Server struct {
		Host       string `yaml:"host"`
		Port       uint16 `yaml:"port"`
		Proxied    bool   `yaml:"proxied"`
		AssetsPath string `yaml:"assets-path"`
		BaseURL    string `yaml:"base-url"`
	} `yaml:"server"`
	Auth struct {
		SecretKey string           `yaml:"secret-key"`
		Users     map[string]*User `yaml:"users"`
	} `yaml:"auth"`
	Document struct {
		Head template.HTML `yaml:"head"`
	} `yaml:"document"`
	Theme struct {
		ThemeProperties `yaml:",inline"`
		CustomCSSFile   string `yaml:"custom-css-file"`
		DisablePicker bool                                     `yaml:"disable-picker"`
		Presets       OrderedYAMLMap[string, *ThemeProperties] `yaml:"presets"`
	} `yaml:"theme"`
	Branding struct {
		HideFooter         bool          `yaml:"hide-footer"`
		CustomFooter       template.HTML `yaml:"custom-footer"`
		LogoText           string        `yaml:"logo-text"`
		LogoURL            string        `yaml:"logo-url"`
		FaviconURL         string        `yaml:"favicon-url"`
		FaviconType        string        `yaml:"-"`
		AppName            string        `yaml:"app-name"`
		AppIconURL         string        `yaml:"app-icon-url"`
		AppBackgroundColor string        `yaml:"app-background-color"`
	} `yaml:"branding"`
	Pages []Page `yaml:"pages"`
}
type User struct {
	Password           string `yaml:"password"`
	PasswordHashString string `yaml:"password-hash"`
	PasswordHash       []byte `yaml:"-"`
}
type Page struct {
	Title                  string  `yaml:"name"`
	Slug                   string  `yaml:"slug"`
	Width                  string  `yaml:"width"`
	DesktopNavigationWidth string  `yaml:"desktop-navigation-width"`
	ShowMobileHeader       bool    `yaml:"show-mobile-header"`
	HideDesktopNavigation  bool    `yaml:"hide-desktop-navigation"`
	CenterVertically       bool    `yaml:"center-vertically"`
	HeadWidgets            Widgets `yaml:"head-widgets"`
	Columns                []struct {
		Size    string  `yaml:"size"`
		Widgets Widgets `yaml:"widgets"`
	} `yaml:"columns"`
	PrimaryColumnIndex int8       `yaml:"-"`
	Mu                 sync.Mutex `yaml:"-"`
}
</file>

<file path="internal/models/fields.go">
package models
import (
	"crypto/tls"
	"fmt"
	"html/template"
	"net/http"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"time"
	"github.com/limpdev/gander/internal/common"
	"gopkg.in/yaml.v3"
)
var hslColorFieldPattern = regexp.MustCompile(`^(?:hsla?\()?([\d\.]+)(?: |,)+([\d\.]+)%?(?: |,)+([\d\.]+)%?\)?$`)
const (
	hslHueMax        = 360
	hslSaturationMax = 100
	hslLightnessMax  = 100
)
type HSLColorField struct {
	H float64
	S float64
	L float64
}
func (c *HSLColorField) String() string {
	return fmt.Sprintf("hsl(%.1f, %.1f%%, %.1f%%)", c.H, c.S, c.L)
}
func (c *HSLColorField) ToHex() string {
	return common.HslToHex(c.H, c.S, c.L)
}
func (c1 *HSLColorField) SameAs(c2 *HSLColorField) bool {
	if c1 == nil && c2 == nil {
		return true
	}
	if c1 == nil || c2 == nil {
		return false
	}
	return c1.H == c2.H && c1.S == c2.S && c1.L == c2.L
}
func (c *HSLColorField) UnmarshalYAML(node *yaml.Node) error {
	var value string
	if err := node.Decode(&value); err != nil {
		return err
	}
	matches := hslColorFieldPattern.FindStringSubmatch(value)
	if len(matches) != 4 {
		return fmt.Errorf("invalid HSL color format: %s", value)
	}
	hue, err := strconv.ParseFloat(matches[1], 64)
	if err != nil {
		return err
	}
	if hue > hslHueMax {
		return fmt.Errorf("HSL hue must be between 0 and %d", hslHueMax)
	}
	saturation, err := strconv.ParseFloat(matches[2], 64)
	if err != nil {
		return err
	}
	if saturation > hslSaturationMax {
		return fmt.Errorf("HSL saturation must be between 0 and %d", hslSaturationMax)
	}
	lightness, err := strconv.ParseFloat(matches[3], 64)
	if err != nil {
		return err
	}
	if lightness > hslLightnessMax {
		return fmt.Errorf("HSL lightness must be between 0 and %d", hslLightnessMax)
	}
	c.H = hue
	c.S = saturation
	c.L = lightness
	return nil
}
var durationFieldPattern = regexp.MustCompile(`^(\d+)(s|m|h|d)$`)
type DurationField time.Duration
func (d *DurationField) UnmarshalYAML(node *yaml.Node) error {
	var value string
	if err := node.Decode(&value); err != nil {
		return err
	}
	matches := durationFieldPattern.FindStringSubmatch(value)
	if len(matches) != 3 {
		return fmt.Errorf("invalid duration format: %s", value)
	}
	duration, err := strconv.Atoi(matches[1])
	if err != nil {
		return err
	}
	switch matches[2] {
	case "s":
		*d = DurationField(time.Duration(duration) * time.Second)
	case "m":
		*d = DurationField(time.Duration(duration) * time.Minute)
	case "h":
		*d = DurationField(time.Duration(duration) * time.Hour)
	case "d":
		*d = DurationField(time.Duration(duration) * 24 * time.Hour)
	}
	return nil
}
type CustomIconField struct {
	URL        template.URL
	AutoInvert bool
}
func NewCustomIconField(value string) CustomIconField {
	const autoInvertPrefix = "auto-invert "
	field := CustomIconField{}
	if strings.HasPrefix(value, autoInvertPrefix) {
		field.AutoInvert = true
		value = strings.TrimPrefix(value, autoInvertPrefix)
	}
	prefix, icon, found := strings.Cut(value, ":")
	if !found {
		field.URL = template.URL(value)
		return field
	}
	basename, ext, found := strings.Cut(icon, ".")
	if !found {
		ext = "svg"
		basename = icon
	}
	if ext != "svg" && ext != "png" {
		ext = "svg"
	}
	switch prefix {
	case "si":
		field.AutoInvert = true
		field.URL = template.URL("https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/" + basename + ".svg")
	case "di":
		field.URL = template.URL("https://cdn.jsdelivr.net/gh/homarr-labs/dashboard-icons/" + ext + "/" + basename + "." + ext)
	case "mdi":
		field.AutoInvert = true
		field.URL = template.URL("https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/" + basename + ".svg")
	case "sh":
		field.URL = template.URL("https://cdn.jsdelivr.net/gh/selfhst/icons/" + ext + "/" + basename + "." + ext)
	default:
		field.URL = template.URL(value)
	}
	return field
}
func (i *CustomIconField) UnmarshalYAML(node *yaml.Node) error {
	var value string
	if err := node.Decode(&value); err != nil {
		return err
	}
	*i = NewCustomIconField(value)
	return nil
}
type ProxyOptionsField struct {
	URL           string        `yaml:"url"`
	AllowInsecure bool          `yaml:"allow-insecure"`
	Timeout       DurationField `yaml:"timeout"`
	Client        *http.Client  `yaml:"-"`
}
func (p *ProxyOptionsField) UnmarshalYAML(node *yaml.Node) error {
	type proxyOptionsFieldAlias ProxyOptionsField
	alias := (*proxyOptionsFieldAlias)(p)
	var proxyURL string
	if err := node.Decode(&proxyURL); err != nil {
		if err := node.Decode(alias); err != nil {
			return err
		}
	}
	if proxyURL == "" && p.URL == "" {
		return nil
	}
	if p.URL != "" {
		proxyURL = p.URL
	}
	parsedUrl, err := url.Parse(proxyURL)
	if err != nil {
		return fmt.Errorf("parsing proxy URL: %v", err)
	}
	timeout := common.DefaultClientTimeout
	if p.Timeout > 0 {
		timeout = time.Duration(p.Timeout)
	}
	p.Client = &http.Client{
		Timeout: timeout,
		Transport: &http.Transport{
			Proxy:           http.ProxyURL(parsedUrl),
			TLSClientConfig: &tls.Config{InsecureSkipVerify: p.AllowInsecure},
		},
	}
	return nil
}
type QueryParametersField map[string][]string
func (q *QueryParametersField) UnmarshalYAML(node *yaml.Node) error {
	var decoded map[string]any
	if err := node.Decode(&decoded); err != nil {
		return err
	}
	*q = make(QueryParametersField)
	// TODO: refactor the duplication in the switch cases if any more types get added
	for key, value := range decoded {
		switch v := value.(type) {
		case string:
			(*q)[key] = []string{v}
		case int, int8, int16, int32, int64, float32, float64:
			(*q)[key] = []string{fmt.Sprintf("%v", v)}
		case bool:
			(*q)[key] = []string{fmt.Sprintf("%t", v)}
		case []string:
			(*q)[key] = append((*q)[key], v...)
		case []any:
			for _, item := range v {
				switch item := item.(type) {
				case string:
					(*q)[key] = append((*q)[key], item)
				case int, int8, int16, int32, int64, float32, float64:
					(*q)[key] = append((*q)[key], fmt.Sprintf("%v", item))
				case bool:
					(*q)[key] = append((*q)[key], fmt.Sprintf("%t", item))
				default:
					return fmt.Errorf("invalid query parameter value type: %T", item)
				}
			}
		default:
			return fmt.Errorf("invalid query parameter value type: %T", value)
		}
	}
	return nil
}
func (q *QueryParametersField) ToQueryString() string {
	query := url.Values{}
	for key, values := range *q {
		for _, value := range values {
			query.Add(key, value)
		}
	}
	return query.Encode()
}
</file>

<file path="internal/models/map.go">
package models
import (
	"fmt"
	"iter"
	"maps"
	"gopkg.in/yaml.v3"
)
// Read-only way to store ordered maps from a YAML structure
type OrderedYAMLMap[K comparable, V any] struct {
	keys []K
	data map[K]V
}
func NewOrderedYAMLMap[K comparable, V any](keys []K, values []V) (*OrderedYAMLMap[K, V], error) {
	if len(keys) != len(values) {
		return nil, fmt.Errorf("keys and values must have the same length")
	}
	om := &OrderedYAMLMap[K, V]{
		keys: make([]K, len(keys)),
		data: make(map[K]V, len(keys)),
	}
	copy(om.keys, keys)
	for i := range keys {
		om.data[keys[i]] = values[i]
	}
	return om, nil
}
func (om *OrderedYAMLMap[K, V]) Items() iter.Seq2[K, V] {
	return func(yield func(K, V) bool) {
		for _, key := range om.keys {
			value, ok := om.data[key]
			if !ok {
				continue
			}
			if !yield(key, value) {
				return
			}
		}
	}
}
func (om *OrderedYAMLMap[K, V]) Get(key K) (V, bool) {
	value, ok := om.data[key]
	return value, ok
}
func (self *OrderedYAMLMap[K, V]) Merge(other *OrderedYAMLMap[K, V]) *OrderedYAMLMap[K, V] {
	merged := &OrderedYAMLMap[K, V]{
		keys: make([]K, 0, len(self.keys)+len(other.keys)),
		data: make(map[K]V, len(self.data)+len(other.data)),
	}
	merged.keys = append(merged.keys, self.keys...)
	maps.Copy(merged.data, self.data)
	for _, key := range other.keys {
		if _, exists := self.data[key]; !exists {
			merged.keys = append(merged.keys, key)
		}
	}
	maps.Copy(merged.data, other.data)
	return merged
}
func (om *OrderedYAMLMap[K, V]) UnmarshalYAML(node *yaml.Node) error {
	if node.Kind != yaml.MappingNode {
		return fmt.Errorf("orderedMap: expected mapping node, got %d", node.Kind)
	}
	if len(node.Content)%2 != 0 {
		return fmt.Errorf("orderedMap: expected even number of content items, got %d", len(node.Content))
	}
	om.keys = make([]K, len(node.Content)/2)
	om.data = make(map[K]V, len(node.Content)/2)
	for i := 0; i < len(node.Content); i += 2 {
		keyNode := node.Content[i]
		valueNode := node.Content[i+1]
		var key K
		if err := keyNode.Decode(&key); err != nil {
			return fmt.Errorf("orderedMap: decoding key: %v", err)
		}
		if _, ok := om.data[key]; ok {
			return fmt.Errorf("orderedMap: duplicate key %v", key)
		}
		var value V
		if err := valueNode.Decode(&value); err != nil {
			return fmt.Errorf("orderedMap: decoding value: %v", err)
		}
		(*om).keys[i/2] = key
		(*om).data[key] = value
	}
	return nil
}
</file>

<file path="internal/models/theme.go">
package models
import (
	"fmt"
	"html/template"
	"github.com/limpdev/gander/internal/common"
	"github.com/limpdev/gander/internal/web"
)
var (
	StyleTemplate         = web.MustParseTemplate("theme-style.gotmpl")
	PresetPreviewTemplate = web.MustParseTemplate("theme-preset-preview.html")
)
type ThemeProperties struct {
	BackgroundColor          *HSLColorField `yaml:"background-color"`
	PrimaryColor             *HSLColorField `yaml:"primary-color"`
	PositiveColor            *HSLColorField `yaml:"positive-color"`
	NegativeColor            *HSLColorField `yaml:"negative-color"`
	Light                    bool           `yaml:"light"`
	ContrastMultiplier       float32        `yaml:"contrast-multiplier"`
	TextSaturationMultiplier float32        `yaml:"text-saturation-multiplier"`
	Key                  string        `yaml:"-"`
	CSS                  template.CSS  `yaml:"-"`
	PreviewHTML          template.HTML `yaml:"-"`
	BackgroundColorAsHex string        `yaml:"-"`
}
func (t *ThemeProperties) Initialize() error {
	css, err := common.ExecuteTemplateToString(StyleTemplate, t)
	if err != nil {
		return fmt.Errorf("compiling theme style: %v", err)
	}
	t.CSS = template.CSS(common.WhitespaceAtBeginningOfLinePattern.ReplaceAllString(css, ""))
	previewHTML, err := common.ExecuteTemplateToString(PresetPreviewTemplate, t)
	if err != nil {
		return fmt.Errorf("compiling theme preview: %v", err)
	}
	t.PreviewHTML = template.HTML(previewHTML)
	if t.BackgroundColor != nil {
		t.BackgroundColorAsHex = t.BackgroundColor.ToHex()
	} else {
		t.BackgroundColorAsHex = "#151519"
	}
	return nil
}
func (t1 *ThemeProperties) SameAs(t2 *ThemeProperties) bool {
	if t1 == nil && t2 == nil {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.Light != t2.Light {
		return false
	}
	if t1.ContrastMultiplier != t2.ContrastMultiplier {
		return false
	}
	if t1.TextSaturationMultiplier != t2.TextSaturationMultiplier {
		return false
	}
	if !t1.BackgroundColor.SameAs(t2.BackgroundColor) {
		return false
	}
	if !t1.PrimaryColor.SameAs(t2.PrimaryColor) {
		return false
	}
	if !t1.PositiveColor.SameAs(t2.PositiveColor) {
		return false
	}
	if !t1.NegativeColor.SameAs(t2.NegativeColor) {
		return false
	}
	return true
}
</file>

<file path="internal/models/widget.go">
package models
import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"html/template"
	"log/slog"
	"math"
	"net/http"
	"sync/atomic"
	"time"
	"gopkg.in/yaml.v3"
)
var widgetIDCounter atomic.Uint64
type Widget interface {
	// These need to be exported because they get called in templates
	Render() template.HTML
	GetType() string
	GetID() uint64
	Initialize() error
	RequiresUpdate(*time.Time) bool
	SetProviders(*WidgetProviders)
	Update(context.Context)
	SetID(uint64)
	HandleRequest(w http.ResponseWriter, r *http.Request)
	SetHideHeader(bool)
}
type Widgets []Widget
// Registry for widget factories
var widgetFactories = make(map[string]func() Widget)
func RegisterWidget(name string, factory func() Widget) {
	widgetFactories[name] = factory
}
func NewWidget(widgetType string) (Widget, error) {
	if widgetType == "" {
		return nil, errors.New("widget 'type' property is empty or not specified")
	}
	factory, ok := widgetFactories[widgetType]
	if !ok {
		return nil, fmt.Errorf("unknown widget type: %s", widgetType)
	}
	w := factory()
	w.SetID(widgetIDCounter.Add(1))
	return w, nil
}
func (w *Widgets) UnmarshalYAML(node *yaml.Node) error {
	var nodes []yaml.Node
	if err := node.Decode(&nodes); err != nil {
		return err
	}
	for _, node := range nodes {
		meta := struct {
			Type string `yaml:"type"`
		}{}
		if err := node.Decode(&meta); err != nil {
			return err
		}
		widget, err := NewWidget(meta.Type)
		if err != nil {
			return fmt.Errorf("line %d: %w", node.Line, err)
		}
		if err = node.Decode(widget); err != nil {
			return err
		}
		*w = append(*w, widget)
	}
	return nil
}
type CacheType int
const (
	CacheTypeInfinite CacheType = iota
	CacheTypeDuration
	CacheTypeOnTheHour
)
type WidgetBase struct {
	ID                  uint64           `yaml:"-"`
	Providers           *WidgetProviders `yaml:"-"`
	Type                string           `yaml:"type"`
	Title               string           `yaml:"title"`
	TitleURL            string           `yaml:"title-url"`
	HideHeader          bool             `yaml:"hide-header"`
	CSSClass            string           `yaml:"css-class"`
	CustomCacheDuration DurationField    `yaml:"cache"`
	ContentAvailable    bool             `yaml:"-"`
	WIP                 bool             `yaml:"-"`
	Error               error            `yaml:"-"`
	Notice              error            `yaml:"-"`
	templateBuffer      bytes.Buffer     `yaml:"-"`
	cacheDuration       time.Duration    `yaml:"-"`
	cacheType           CacheType        `yaml:"-"`
	nextUpdate          time.Time        `yaml:"-"`
	updateRetriedTimes  int              `yaml:"-"`
}
type WidgetProviders struct {
	AssetResolver func(string) string
}
func (w *WidgetBase) RequiresUpdate(now *time.Time) bool {
	if w.cacheType == CacheTypeInfinite {
		return false
	}
	if w.nextUpdate.IsZero() {
		return true
	}
	return now.After(w.nextUpdate)
}
func (w *WidgetBase) IsWIP() bool {
	return w.WIP
}
func (w *WidgetBase) Update(ctx context.Context) {
}
func (w *WidgetBase) GetID() uint64 {
	return w.ID
}
func (w *WidgetBase) SetID(id uint64) {
	w.ID = id
}
func (w *WidgetBase) SetHideHeader(value bool) {
	w.HideHeader = value
}
func (widget *WidgetBase) HandleRequest(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "not implemented", http.StatusNotImplemented)
}
func (w *WidgetBase) GetType() string {
	return w.Type
}
func (w *WidgetBase) SetProviders(providers *WidgetProviders) {
	w.Providers = providers
}
func (w *WidgetBase) RenderTemplate(data any, t *template.Template) template.HTML {
	w.templateBuffer.Reset()
	err := t.Execute(&w.templateBuffer, data)
	if err != nil {
		w.ContentAvailable = false
		w.Error = err
		slog.Error("Failed to render template", "error", err)
		// need to immediately re-render with the error,
		// otherwise risk breaking the page since the widget
		// will likely be partially rendered with tags not closed.
		w.templateBuffer.Reset()
		err2 := t.Execute(&w.templateBuffer, data)
		if err2 != nil {
			slog.Error("Failed to render error within widget", "error", err2, "initial_error", err)
			w.templateBuffer.Reset()
		}
	}
	return template.HTML(w.templateBuffer.String())
}
func (w *WidgetBase) WithTitle(title string) *WidgetBase {
	if w.Title == "" {
		w.Title = title
	}
	return w
}
func (w *WidgetBase) WithTitleURL(titleURL string) *WidgetBase {
	if w.TitleURL == "" {
		w.TitleURL = titleURL
	}
	return w
}
func (w *WidgetBase) WithCacheDuration(duration time.Duration) *WidgetBase {
	w.cacheType = CacheTypeDuration
	if duration == -1 || w.CustomCacheDuration == 0 {
		w.cacheDuration = duration
	} else {
		w.cacheDuration = time.Duration(w.CustomCacheDuration)
	}
	return w
}
func (w *WidgetBase) WithCacheOnTheHour() *WidgetBase {
	w.cacheType = CacheTypeOnTheHour
	return w
}
func (w *WidgetBase) WithNotice(err error) *WidgetBase {
	w.Notice = err
	return w
}
func (w *WidgetBase) WithError(err error) *WidgetBase {
	if err == nil && !w.ContentAvailable {
		w.ContentAvailable = true
	}
	w.Error = err
	return w
}
func (w *WidgetBase) CanContinueUpdateAfterHandlingErr(err error) bool {
	// TODO errors
	// if errors.Is(err, errPartialContent) { ... }
	// I need errPartialContent from somewhere.
	// It was in widgets/utils.go. I should move it to models or common.
	if err != nil {
		w.ScheduleEarlyUpdate()
		// Simplification for now, assuming logic handling is adjusted
		w.WithError(err)
		w.WithNotice(nil)
		return false
	}
	w.WithNotice(nil)
	w.WithError(nil)
	w.ScheduleNextUpdate()
	return true
}
func (w *WidgetBase) GetNextUpdateTime() time.Time {
	now := time.Now()
	if w.cacheType == CacheTypeDuration {
		return now.Add(w.cacheDuration)
	}
	if w.cacheType == CacheTypeOnTheHour {
		return now.Add(time.Duration(
			((60-now.Minute())*60)-now.Second(),
		) * time.Second)
	}
	return time.Time{}
}
func (w *WidgetBase) ScheduleNextUpdate() *WidgetBase {
	w.nextUpdate = w.GetNextUpdateTime()
	w.updateRetriedTimes = 0
	return w
}
func (w *WidgetBase) ScheduleEarlyUpdate() *WidgetBase {
	w.updateRetriedTimes++
	if w.updateRetriedTimes > 5 {
		w.updateRetriedTimes = 5
	}
	nextEarlyUpdate := time.Now().Add(time.Duration(math.Pow(float64(w.updateRetriedTimes), 2)) * time.Minute)
	nextUsualUpdate := w.GetNextUpdateTime()
	if nextEarlyUpdate.After(nextUsualUpdate) {
		w.nextUpdate = nextUsualUpdate
	} else {
		w.nextUpdate = nextEarlyUpdate
	}
	return w
}
</file>

<file path="internal/web/embed.go">
package web
import (
	"bytes"
	"crypto/md5"
	"embed"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"log"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)
//go:embed static
var _staticFS embed.FS
//go:embed templates
var _templateFS embed.FS
var staticFS, _ = fs.Sub(_staticFS, "static")
var TemplateFS, _ = fs.Sub(_templateFS, "templates")
func readAllFromStaticFS(path string) ([]byte, error) {
	// For some reason fs.FS only works with forward slashes, so in case we're
	// running on Windows or pass paths with backslashes we need to replace them.
	path = strings.ReplaceAll(path, "\\", "/")
	file, err := staticFS.Open(path)
	if err != nil {
		return nil, err
	}
	return io.ReadAll(file)
}
var staticFSHash = func() string {
	hash, err := computeFSHash(staticFS)
	if err != nil {
		log.Printf("Could not compute static assets cache key: %v", err)
		return strconv.FormatInt(time.Now().Unix(), 10)
	}
	return hash
}()
func computeFSHash(files fs.FS) (string, error) {
	hash := md5.New()
	err := fs.WalkDir(files, ".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		file, err := files.Open(path)
		if err != nil {
			return err
		}
		if _, err := io.Copy(hash, file); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(hash.Sum(nil))[:10], nil
}
var cssImportPattern = regexp.MustCompile(`(?m)^@import "(.*?)";$`)
var cssSingleLineCommentPattern = regexp.MustCompile(`(?m)^\s*\/\*.*?\*\/$`)
var whitespaceAtBeginningOfLinePattern = regexp.MustCompile(`(?m)^\s+`)
// Yes, we bundle at runtime, give comptime pls
var bundledCSSContents = func() []byte {
	const mainFilePath = "css/main.css"
	var recursiveParseImports func(path string, depth int) ([]byte, error)
	recursiveParseImports = func(path string, depth int) ([]byte, error) {
		if depth > 20 {
			return nil, errors.New("maximum import depth reached, is one of your imports circular?")
		}
		mainFileContents, err := readAllFromStaticFS(path)
		if err != nil {
			return nil, err
		}
		// Normalize line endings, otherwise the \r's make the regex not match
		mainFileContents = bytes.ReplaceAll(mainFileContents, []byte("\r\n"), []byte("\n"))
		mainFileDir := filepath.Dir(path)
		var importLastErr error
		parsed := cssImportPattern.ReplaceAllFunc(mainFileContents, func(match []byte) []byte {
			if importLastErr != nil {
				return nil
			}
			matches := cssImportPattern.FindSubmatch(match)
			if len(matches) != 2 {
				importLastErr = fmt.Errorf(
					"import didn't return expected number of capture groups: %s, expected 2, got %d",
					match, len(matches),
				)
				return nil
			}
			importFilePath := filepath.Join(mainFileDir, string(matches[1]))
			importContents, err := recursiveParseImports(importFilePath, depth+1)
			if err != nil {
				importLastErr = err
				return nil
			}
			return importContents
		})
		if importLastErr != nil {
			return nil, importLastErr
		}
		return parsed, nil
	}
	contents, err := recursiveParseImports(mainFilePath, 0)
	if err != nil {
		panic(fmt.Sprintf("building CSS bundle: %v", err))
	}
	// We could strip a bunch more unnecessary characters, but the biggest
	// win comes from removing the whitespace at the beginning of lines
	// since that's at least 4 bytes per property, which yielded a ~20% reduction.
	contents = cssSingleLineCommentPattern.ReplaceAll(contents, nil)
	contents = whitespaceAtBeginningOfLinePattern.ReplaceAll(contents, nil)
	contents = bytes.ReplaceAll(contents, []byte("\n"), []byte(""))
	return contents
}()
</file>

<file path="pkg/sysinfo/sysinfo.go">
package sysinfo
import (
	"fmt"
	"math"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/host"
	"github.com/shirou/gopsutil/v4/load"
	"github.com/shirou/gopsutil/v4/mem"
	"github.com/shirou/gopsutil/v4/sensors"
)
type timestampJSON struct {
	time.Time
}
func (t timestampJSON) MarshalJSON() ([]byte, error) {
	return []byte(strconv.FormatInt(t.Unix(), 10)), nil
}
func (t *timestampJSON) UnmarshalJSON(data []byte) error {
	i, err := strconv.ParseInt(string(data), 10, 64)
	if err != nil {
		return err
	}
	t.Time = time.Unix(i, 0)
	return nil
}
type SystemInfo struct {
	HostInfoIsAvailable bool          `json:"host_info_is_available"`
	BootTime            timestampJSON `json:"boot_time"`
	Hostname            string        `json:"hostname"`
	Platform            string        `json:"platform"`
	CPU struct {
		LoadIsAvailable bool  `json:"load_is_available"`
		Load1Percent    uint8 `json:"load1_percent"`
		Load15Percent   uint8 `json:"load15_percent"`
		TemperatureIsAvailable bool  `json:"temperature_is_available"`
		TemperatureC           uint8 `json:"temperature_c"`
	} `json:"cpu"`
	Memory struct {
		IsAvailable bool   `json:"memory_is_available"`
		TotalMB     uint64 `json:"total_mb"`
		UsedMB      uint64 `json:"used_mb"`
		UsedPercent uint8  `json:"used_percent"`
		SwapIsAvailable bool   `json:"swap_is_available"`
		SwapTotalMB     uint64 `json:"swap_total_mb"`
		SwapUsedMB      uint64 `json:"swap_used_mb"`
		SwapUsedPercent uint8  `json:"swap_used_percent"`
	} `json:"memory"`
	Mountpoints []MountpointInfo `json:"mountpoints"`
}
type MountpointInfo struct {
	Path        string `json:"path"`
	Name        string `json:"name"`
	TotalMB     uint64 `json:"total_mb"`
	UsedMB      uint64 `json:"used_mb"`
	UsedPercent uint8  `json:"used_percent"`
}
type SystemInfoRequest struct {
	CPUTempSensor            string                       `yaml:"cpu-temp-sensor"`
	HideMountpointsByDefault bool                         `yaml:"hide-mountpoints-by-default"`
	Mountpoints              map[string]MointpointRequest `yaml:"mountpoints"`
}
type MointpointRequest struct {
	Name string `yaml:"name"`
	Hide *bool  `yaml:"hide"`
}
// Currently caches hostname indefinitely which isn't ideal
// Potential issue with caching boot time as it may not initially get reported correctly:
// https://github.com/shirou/gopsutil/issues/842#issuecomment-1908972344
type cacheableHostInfo struct {
	available bool
	hostname  string
	platform  string
	bootTime  timestampJSON
}
var cachedHostInfo cacheableHostInfo
func getHostInfo() (cacheableHostInfo, error) {
	var err error
	info := cacheableHostInfo{}
	info.hostname, err = os.Hostname()
	if err != nil {
		return info, err
	}
	info.platform, _, _, err = host.PlatformInformation()
	if err != nil {
		return info, err
	}
	bootTime, err := host.BootTime()
	if err != nil {
		return info, err
	}
	info.bootTime = timestampJSON{time.Unix(int64(bootTime), 0)}
	info.available = true
	return info, nil
}
func Collect(req *SystemInfoRequest) (*SystemInfo, []error) {
	if req == nil {
		req = &SystemInfoRequest{}
	}
	var errs []error
	addErr := func(err error) {
		errs = append(errs, err)
	}
	info := &SystemInfo{
		Mountpoints: []MountpointInfo{},
	}
	applyCachedHostInfo := func() {
		info.HostInfoIsAvailable = true
		info.BootTime = cachedHostInfo.bootTime
		info.Hostname = cachedHostInfo.hostname
		info.Platform = cachedHostInfo.platform
	}
	if cachedHostInfo.available {
		applyCachedHostInfo()
	} else {
		hostInfo, err := getHostInfo()
		if err == nil {
			cachedHostInfo = hostInfo
			applyCachedHostInfo()
		} else {
			addErr(fmt.Errorf("getting host info: %v", err))
		}
	}
	coreCount, err := cpu.Counts(true)
	if err == nil {
		loadAvg, err := load.Avg()
		if err == nil {
			info.CPU.LoadIsAvailable = true
			if runtime.GOOS == "windows" {
				// The numbers returned here seem unreliable on Windows. Even with the CPU pegged
				// at close to 50% for multiple minutes, load1 is sometimes way under or way over
				// with no clear pattern. Dividing by core count gives numbers that are way too
				// low so that's likely not necessary as it is with unix.
				info.CPU.Load1Percent = uint8(math.Min(loadAvg.Load1*100, 100))
				info.CPU.Load15Percent = uint8(math.Min(loadAvg.Load15*100, 100))
			} else {
				info.CPU.Load1Percent = uint8(math.Min((loadAvg.Load1/float64(coreCount))*100, 100))
				info.CPU.Load15Percent = uint8(math.Min((loadAvg.Load15/float64(coreCount))*100, 100))
			}
		} else {
			addErr(fmt.Errorf("getting load avg: %v", err))
		}
	} else {
		addErr(fmt.Errorf("getting core count: %v", err))
	}
	memory, err := mem.VirtualMemory()
	if err == nil {
		info.Memory.IsAvailable = true
		info.Memory.TotalMB = memory.Total / 1024 / 1024
		info.Memory.UsedMB = memory.Used / 1024 / 1024
		info.Memory.UsedPercent = uint8(math.Min(memory.UsedPercent, 100))
	} else {
		addErr(fmt.Errorf("getting memory info: %v", err))
	}
	swapMemory, err := mem.SwapMemory()
	if err == nil {
		info.Memory.SwapIsAvailable = true
		info.Memory.SwapTotalMB = swapMemory.Total / 1024 / 1024
		info.Memory.SwapUsedMB = swapMemory.Used / 1024 / 1024
		info.Memory.SwapUsedPercent = uint8(math.Min(swapMemory.UsedPercent, 100))
	} else {
		addErr(fmt.Errorf("getting swap memory info: %v", err))
	}
	// currently disabled on Windows because it requires elevated privilidges, otherwise
	// keeps returning a single sensor with key "ACPI\\ThermalZone\\TZ00_0" which
	// doesn't seem to be the CPU sensor or correspond to anything useful when
	// compared against the temperatures Libre Hardware Monitor reports.
	// Also disabled on the bsd's because it's not implemented by go-psutil for them
	if runtime.GOOS != "windows" && runtime.GOOS != "openbsd" && runtime.GOOS != "netbsd" && runtime.GOOS != "freebsd" {
		sensorReadings, err := sensors.SensorsTemperatures()
		_, errIsWarning := err.(*sensors.Warnings)
		if err == nil || errIsWarning {
			if req.CPUTempSensor != "" {
				for i := range sensorReadings {
					if sensorReadings[i].SensorKey == req.CPUTempSensor {
						info.CPU.TemperatureIsAvailable = true
						info.CPU.TemperatureC = uint8(sensorReadings[i].Temperature)
						break
					}
				}
				if !info.CPU.TemperatureIsAvailable {
					addErr(fmt.Errorf("CPU temperature sensor %s not found", req.CPUTempSensor))
				}
			} else if cpuTempSensor := inferCPUTempSensor(sensorReadings); cpuTempSensor != nil {
				info.CPU.TemperatureIsAvailable = true
				info.CPU.TemperatureC = uint8(cpuTempSensor.Temperature)
			}
		} else {
			addErr(fmt.Errorf("getting sensor readings: %v", err))
		}
	}
	addedMountpoints := map[string]struct{}{}
	addMountpointInfo := func(requestedPath string, mpReq MointpointRequest) {
		if _, exists := addedMountpoints[requestedPath]; exists {
			return
		}
		isHidden := req.HideMountpointsByDefault
		if mpReq.Hide != nil {
			isHidden = *mpReq.Hide
		}
		if isHidden {
			return
		}
		usage, err := disk.Usage(requestedPath)
		if err == nil {
			mpInfo := MountpointInfo{
				Path:        requestedPath,
				Name:        mpReq.Name,
				TotalMB:     usage.Total / 1024 / 1024,
				UsedMB:      usage.Used / 1024 / 1024,
				UsedPercent: uint8(math.Min(usage.UsedPercent, 100)),
			}
			info.Mountpoints = append(info.Mountpoints, mpInfo)
			addedMountpoints[requestedPath] = struct{}{}
		} else {
			addErr(fmt.Errorf("getting filesystem usage for %s: %v", requestedPath, err))
		}
	}
	if !req.HideMountpointsByDefault {
		filesystems, err := disk.Partitions(false)
		if err == nil {
			for _, fs := range filesystems {
				addMountpointInfo(fs.Mountpoint, req.Mountpoints[fs.Mountpoint])
			}
		} else {
			addErr(fmt.Errorf("getting filesystems: %v", err))
		}
	}
	for mountpoint, mpReq := range req.Mountpoints {
		addMountpointInfo(mountpoint, mpReq)
	}
	sort.Slice(info.Mountpoints, func(a, b int) bool {
		return info.Mountpoints[a].UsedPercent > info.Mountpoints[b].UsedPercent
	})
	return info, errs
}
func inferCPUTempSensor(sensors []sensors.TemperatureStat) *sensors.TemperatureStat {
	for i := range sensors {
		switch sensors[i].SensorKey {
		case
			"coretemp_package_id_0", // intel / linux
			"coretemp",              // intel / linux
			"k10temp",               // amd / linux
			"zenpower",              // amd / linux
			"cpu_thermal":           // raspberry pi / linux
			return &sensors[i]
		}
	}
	return nil
}
</file>

<file path="internal/app/cli.go">
package app
import (
	"flag"
	"fmt"
	"os"
	"strings"
	"github.com/limpdev/gander/internal/utils"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/sensors"
)
type Intent uint8
const (
	IntentVersionPrint Intent = iota
	IntentServe
	IntentConfigValidate
	IntentConfigPrint
	IntentDiagnose
	IntentSensorsPrint
	IntentMountpointInfo
	IntentSecretMake
	IntentPasswordHash
)
type Options struct {
	Intent     Intent
	ConfigPath string
	Args       []string
}
func ParseCliOptions() (*Options, error) {
	var args []string
	args = os.Args[1:]
	if len(args) == 1 && (args[0] == "--version" || args[0] == "-v" || args[0] == "version") {
		return &Options{
			Intent: IntentVersionPrint,
		}, nil
	}
	flags := flag.NewFlagSet("", flag.ExitOnError)
	flags.Usage = func() {
		fmt.Println("Usage: glance [options] command")
		fmt.Println("\nOptions:")
		flags.PrintDefaults()
		fmt.Println("\nCommands:")
		fmt.Println("  config:validate       Validate the config file")
		fmt.Println("  config:print          Print the parsed config file with embedded includes")
		fmt.Println("  password:hash <pwd>   Hash a password")
		fmt.Println("  secret:make           Generate a random secret key")
		fmt.Println("  sensors:print         List all sensors")
		fmt.Println("  mountpoint:info       Print information about a given mountpoint path")
		fmt.Println("  diagnose              Run diagnostic checks")
	}
	configPath := flags.String("config", "glance.yml", "Set config path")
	err := flags.Parse(os.Args[1:])
	if err != nil {
		return nil, err
	}
	var intent Intent
	args = flags.Args()
	unknownCommandErr := fmt.Errorf("unknown command: %s", strings.Join(args, " "))
	if len(args) == 0 {
		intent = IntentServe
	} else if len(args) == 1 {
		if args[0] == "config:validate" {
			intent = IntentConfigValidate
		} else if args[0] == "config:print" {
			intent = IntentConfigPrint
		} else if args[0] == "sensors:print" {
			intent = IntentSensorsPrint
		} else if args[0] == "diagnose" {
			intent = IntentDiagnose
		} else if args[0] == "secret:make" {
			intent = IntentSecretMake
		} else {
			return nil, unknownCommandErr
		}
	} else if len(args) == 2 {
		if args[0] == "password:hash" {
			intent = IntentPasswordHash
		} else {
			return nil, unknownCommandErr
		}
	} else if len(args) == 2 {
		if args[0] == "mountpoint:info" {
			intent = IntentMountpointInfo
		} else {
			return nil, unknownCommandErr
		}
	} else {
		return nil, unknownCommandErr
	}
	return &Options{
		Intent:     intent,
		ConfigPath: *configPath,
		Args:       args,
	}, nil
}
func CliSensorsPrint() int {
	tempSensors, err := sensors.SensorsTemperatures()
	if err != nil {
		if warns, ok := err.(*sensors.Warnings); ok {
			fmt.Printf("Could not retrieve information for some sensors (%v):\n", err)
			for _, w := range warns.List {
				fmt.Printf(" - %v\n", w)
			}
			fmt.Println()
		} else {
			fmt.Printf("Failed to retrieve sensor information: %v\n", err)
			return 1
		}
	}
	if len(tempSensors) == 0 {
		fmt.Println("No sensors found")
		return 0
	}
	fmt.Println("Sensors found:")
	for _, sensor := range tempSensors {
		fmt.Printf(" %s: %.1fC\n", sensor.SensorKey, sensor.Temperature)
	}
	return 0
}
func CliMountpointInfo(requestedPath string) int {
	usage, err := disk.Usage(requestedPath)
	if err != nil {
		fmt.Printf("Failed to retrieve info for path %s: %v\n", requestedPath, err)
		if warns, ok := err.(*disk.Warnings); ok {
			for _, w := range warns.List {
				fmt.Printf(" - %v\n", w)
			}
		}
		return 1
	}
	fmt.Println("Path:", usage.Path)
	fmt.Println("FS type:", utils.Ternary(usage.Fstype == "", "unknown", usage.Fstype))
	fmt.Printf("Used percent: %.1f%%\n", usage.UsedPercent)
	return 0
}
</file>

<file path="internal/app/diagnose.go">
package app
import (
	"context"
	"fmt"
	"io"
	"net"
	"net/http"
	"runtime"
	"strings"
	"sync"
	"time"
)
const httpTestRequestTimeout = 15 * time.Second
var diagnosticSteps = []diagnosticStep{
	{
		name: "resolve cloudflare.com through Cloudflare DoH",
		fn: func() (string, error) {
			return testHttpRequestWithHeaders("GET", "https://1.1.1.1/dns-query?name=cloudflare.com", map[string]string{
				"accept": "application/dns-json",
			}, 200)
		},
	},
	{
		name: "resolve cloudflare.com through Google DoH",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://8.8.8.8/resolve?name=cloudflare.com", 200)
		},
	},
	{
		name: "resolve github.com",
		fn: func() (string, error) {
			return testDNSResolution("github.com")
		},
	},
	{
		name: "resolve reddit.com",
		fn: func() (string, error) {
			return testDNSResolution("reddit.com")
		},
	},
	{
		name: "resolve twitch.tv",
		fn: func() (string, error) {
			return testDNSResolution("twitch.tv")
		},
	},
	{
		name: "fetch data from YouTube RSS feed",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://www.youtube.com/feeds/videos.xml?channel_id=UCZU9T1ceaOgwfLRq7OKFU4Q", 200)
		},
	},
	{
		name: "fetch data from Twitch.tv GQL",
		fn: func() (string, error) {
			// this should always return 0 bytes, we're mainly looking for a 200 status code
			return testHttpRequest("OPTIONS", "https://gql.twitch.tv/gql", 200)
		},
	},
	{
		name: "fetch data from GitHub API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://api.github.com", 200)
		},
	},
	{
		name: "fetch data from Open-Meteo API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://geocoding-api.open-meteo.com/v1/search?name=London", 200)
		},
	},
	{
		name: "fetch data from Reddit API",
		fn: func() (string, error) {
			return testHttpRequestWithHeaders("GET", "https://www.reddit.com/search.json", map[string]string{
				"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0",
			}, 200)
		},
	},
	{
		name: "fetch data from Yahoo finance API",
		fn: func() (string, error) {
			return testHttpRequestWithHeaders("GET", "https://query1.finance.yahoo.com/v8/finance/chart/NVDA", map[string]string{
				"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0",
			}, 200)
		},
	},
	{
		name: "fetch data from Hacker News Firebase API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://hacker-news.firebaseio.com/v0/topstories.json", 200)
		},
	},
	{
		name: "fetch data from Docker Hub API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://hub.docker.com/v2/namespaces/library/repositories/ubuntu/tags/latest", 200)
		},
	},
}
func runDiagnostic() {
	fmt.Println("```")
	fmt.Println("Glance version: " + buildVersion)
	fmt.Println("Go version: " + runtime.Version())
	fmt.Printf("Platform: %s / %s / %d CPUs\n", runtime.GOOS, runtime.GOARCH, runtime.NumCPU())
	fmt.Println("In Docker container: " + ternary(isRunningInsideDockerContainer(), "yes", "no"))
	fmt.Printf("\nChecking network connectivity, this may take up to %d seconds...\n\n", int(httpTestRequestTimeout.Seconds()))
	var wg sync.WaitGroup
	for i := range diagnosticSteps {
		step := &diagnosticSteps[i]
		wg.Add(1)
		go func() {
			defer wg.Done()
			start := time.Now()
			step.extraInfo, step.err = step.fn()
			step.elapsed = time.Since(start)
		}()
	}
	wg.Wait()
	for _, step := range diagnosticSteps {
		var extraInfo string
		if step.extraInfo != "" {
			extraInfo = "| " + step.extraInfo + " "
		}
		fmt.Printf(
			"%s %s %s| %dms\n",
			ternary(step.err == nil, " Can", " Can't"),
			step.name,
			extraInfo,
			step.elapsed.Milliseconds(),
		)
		if step.err != nil {
			fmt.Printf(" error: %v\n", step.err)
		}
	}
	fmt.Println("```")
}
type diagnosticStep struct {
	name      string
	fn        func() (string, error)
	extraInfo string
	err       error
	elapsed   time.Duration
}
func testHttpRequest(method, url string, expectedStatusCode int) (string, error) {
	return testHttpRequestWithHeaders(method, url, nil, expectedStatusCode)
}
func testHttpRequestWithHeaders(method, url string, headers map[string]string, expectedStatusCode int) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), httpTestRequestTimeout)
	defer cancel()
	request, _ := http.NewRequestWithContext(ctx, method, url, nil)
	for key, value := range headers {
		request.Header.Add(key, value)
	}
	response, err := defaultHTTPClient.Do(request)
	if err != nil {
		return "", err
	}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {
		return "", err
	}
	printableBody := strings.ReplaceAll(string(body), "\n", "")
	if len(printableBody) > 50 {
		printableBody = printableBody[:50] + "..."
	}
	if len(printableBody) > 0 {
		printableBody = ", " + printableBody
	}
	extraInfo := fmt.Sprintf("%d bytes%s", len(body), printableBody)
	if response.StatusCode != expectedStatusCode {
		return extraInfo, fmt.Errorf("expected status code %d, got %d", expectedStatusCode, response.StatusCode)
	}
	return extraInfo, nil
}
func testDNSResolution(domain string) (string, error) {
	ips, err := net.LookupIP(domain)
	var ipStrings []string
	if err == nil {
		for i := range ips {
			ipStrings = append(ipStrings, ips[i].String())
		}
	}
	return strings.Join(ipStrings, ", "), err
}
</file>

<file path="internal/app/glance.go">
package app
import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"
	"golang.org/x/crypto/bcrypt"
	"github.com/limpdev/gander/internal/auth"
	"github.com/limpdev/gander/internal/common"
	"github.com/limpdev/gander/internal/models"
)
var (
	pageTemplate        = common.MustParseTemplate("page.html", "document.html", "footer.html")
	pageContentTemplate = common.MustParseTemplate("page-content.html")
	manifestTemplate    = common.MustParseTemplate("manifest.json")
)
const STATIC_ASSETS_CACHE_DURATION = 24 * time.Hour
var reservedPageSlugs = []string{"login", "logout"}
type Application struct {
	Version   string
	CreatedAt time.Time
	Config    models.Config
	parsedManifest []byte
	slugToPage map[string]*models.Page
	widgetByID map[uint64]models.Widget
	RequiresAuth           bool
	authSecretKey          []byte
	usernameHashToUsername map[string]string
	authAttemptsMu         sync.Mutex
	failedAuthAttempts     map[string]*auth.FailedAuthAttempt
}
func NewApplication(c *models.Config) (*Application, error) {
	app := &Application{
		Version:    BuildVersion,
		CreatedAt:  time.Now(),
		Config:     *c,
		slugToPage: make(map[string]*models.Page),
		widgetByID: make(map[uint64]models.Widget),
	}
	config := &app.Config
	//
	// Init auth
	//
	if len(config.Auth.Users) > 0 {
		secretBytes, err := base64.StdEncoding.DecodeString(config.Auth.SecretKey)
		if err != nil {
			return nil, fmt.Errorf("decoding secret-key: %v", err)
		}
		if len(secretBytes) != auth.AUTH_SECRET_KEY_LENGTH {
			return nil, fmt.Errorf("secret-key must be exactly %d bytes", auth.AUTH_SECRET_KEY_LENGTH)
		}
		app.usernameHashToUsername = make(map[string]string)
		app.failedAuthAttempts = make(map[string]*auth.FailedAuthAttempt)
		app.RequiresAuth = true
		for username := range config.Auth.Users {
			user := config.Auth.Users[username]
			usernameHash, err := auth.ComputeUsernameHash(username, secretBytes)
			if err != nil {
				return nil, fmt.Errorf("computing username hash for user %s: %v", username, err)
			}
			app.usernameHashToUsername[string(usernameHash)] = username
			if user.PasswordHashString != "" {
				user.PasswordHash = []byte(user.PasswordHashString)
				user.PasswordHashString = ""
			} else {
				hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
				if err != nil {
					return nil, fmt.Errorf("hashing password for user %s: %v", username, err)
				}
				user.Password = ""
				user.PasswordHash = hashedPassword
			}
		}
		app.authSecretKey = secretBytes
	}
	//
	// Init themes
	//
	if !config.Theme.DisablePicker {
		themeKeys := make([]string, 0, 2)
		themeProps := make([]*themeProperties, 0, 2)
		defaultDarkTheme, ok := config.Theme.Presets.Get("default-dark")
		if ok && !config.Theme.SameAs(defaultDarkTheme) || !config.Theme.SameAs(&themeProperties{}) {
			themeKeys = append(themeKeys, "default-dark")
			themeProps = append(themeProps, &themeProperties{})
		}
		themeKeys = append(themeKeys, "default-light")
		themeProps = append(themeProps, &themeProperties{
			Light:                    true,
			BackgroundColor:          &hslColorField{240, 13, 95},
			PrimaryColor:             &hslColorField{230, 100, 30},
			NegativeColor:            &hslColorField{0, 70, 50},
			ContrastMultiplier:       1.3,
			TextSaturationMultiplier: 0.5,
		})
		themePresets, err := common.NewOrderedYAMLMap(themeKeys, themeProps)
		if err != nil {
			return nil, fmt.Errorf("creating theme presets: %v", err)
		}
		config.Theme.Presets = *themePresets.Merge(&config.Theme.Presets)
		for key, properties := range config.Theme.Presets.Items() {
			properties.Key = key
			if err := properties.init(); err != nil {
				return nil, fmt.Errorf("initializing preset theme %s: %v", key, err)
			}
		}
	}
	config.Theme.Key = "default"
	if err := config.Theme.init(); err != nil {
		return nil, fmt.Errorf("initializing default theme: %v", err)
	}
	//
	// Init pages
	//
	app.slugToPage[""] = &config.Pages[0]
	providers := &models.WidgetProviders{
		assetResolver: app.StaticAssetPath,
	}
	for p := range config.Pages {
		page := &config.Pages[p]
		page.PrimaryColumnIndex = -1
		if page.Slug == "" {
			page.Slug = titleToSlug(page.Title)
		}
		if slices.Contains(reservedPageSlugs, page.Slug) {
			return nil, fmt.Errorf("page slug \"%s\" is reserved", page.Slug)
		}
		app.slugToPage[page.Slug] = page
		if page.Width == "default" {
			page.Width = ""
		}
		if page.DesktopNavigationWidth == "" && page.DesktopNavigationWidth != "default" {
			page.DesktopNavigationWidth = page.Width
		}
		for i := range page.HeadWidgets {
			widget := page.HeadWidgets[i]
			app.widgetByID[widget.GetID()] = widget
			widget.setProviders(providers)
		}
		for c := range page.Columns {
			column := &page.Columns[c]
			if page.PrimaryColumnIndex == -1 && column.Size == "full" {
				page.PrimaryColumnIndex = int8(c)
			}
			for w := range column.Widgets {
				widget := column.Widgets[w]
				app.widgetByID[widget.GetID()] = widget
				widget.setProviders(providers)
			}
		}
	}
	config.Server.BaseURL = strings.TrimRight(config.Server.BaseURL, "/")
	config.Theme.CustomCSSFile = app.resolveUserDefinedAssetPath(config.Theme.CustomCSSFile)
	config.Branding.LogoURL = app.resolveUserDefinedAssetPath(config.Branding.LogoURL)
	config.Branding.FaviconURL = common.Ternary(
		config.Branding.FaviconURL == "",
		app.StaticAssetPath("favicon.svg"),
		app.resolveUserDefinedAssetPath(config.Branding.FaviconURL),
	)
	config.Branding.FaviconType = common.Ternary(
		strings.HasSuffix(config.Branding.FaviconURL, ".svg"),
		"image/svg+xml",
		"image/png",
	)
	if config.Branding.AppName == "" {
		config.Branding.AppName = "Glance"
	}
	if config.Branding.AppIconURL == "" {
		config.Branding.AppIconURL = app.StaticAssetPath("app-icon.png")
	}
	if config.Branding.AppBackgroundColor == "" {
		config.Branding.AppBackgroundColor = config.Theme.BackgroundColorAsHex
	}
	manifest, err := common.ExecuteTemplateToString(manifestTemplate, templateData{App: app})
	if err != nil {
		return nil, fmt.Errorf("parsing manifest.json: %v", err)
	}
	app.parsedManifest = []byte(manifest)
	return app, nil
}
func (p *models.Page) updateOutdatedWidgets() {
	now := time.Now()
	var wg sync.WaitGroup
	context := context.Background()
	for w := range p.HeadWidgets {
		widget := p.HeadWidgets[w]
		if !widget.RequiresUpdate(&now) {
			continue
		}
		wg.Add(1)
		go func() {
			defer wg.Done()
			widget.Update(context)
		}()
	}
	for c := range p.Columns {
		for w := range p.Columns[c].Widgets {
			widget := p.Columns[c].Widgets[w]
			if !widget.RequiresUpdate(&now) {
				continue
			}
			wg.Add(1)
			go func() {
				defer wg.Done()
				widget.Update(context)
			}()
		}
	}
	wg.Wait()
}
func (a *Application) resolveUserDefinedAssetPath(path string) string {
	if strings.HasPrefix(path, "/assets/") {
		return a.Config.Server.BaseURL + path
	}
	return path
}
type templateRequestData struct {
	Theme *themeProperties
}
type templateData struct {
	App     *Application
	Page    *models.Page
	Request templateRequestData
}
func (a *Application) populateTemplateRequestData(data *templateRequestData, r *http.Request) {
	theme := &a.Config.Theme.themeProperties
	if !a.Config.Theme.DisablePicker {
		selectedTheme, err := r.Cookie("theme")
		if err == nil {
			preset, exists := a.Config.Theme.Presets.Get(selectedTheme.Value)
			if exists {
				theme = preset
			}
		}
	}
	data.Theme = theme
}
func (a *Application) handlePageRequest(w http.ResponseWriter, r *http.Request) {
	page, exists := a.slugToPage[r.PathValue("page")]
	if !exists {
		a.handleNotFound(w, r)
		return
	}
	if a.handleUnauthorizedResponse(w, r, redirectToLogin) {
		return
	}
	data := templateData{
		Page: page,
		App:  a,
	}
	a.populateTemplateRequestData(&data.Request, r)
	var responseBytes bytes.Buffer
	err := pageTemplate.Execute(&responseBytes, data)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(responseBytes.Bytes())
}
func (a *Application) handlePageContentRequest(w http.ResponseWriter, r *http.Request) {
	page, exists := a.slugToPage[r.PathValue("page")]
	if !exists {
		a.handleNotFound(w, r)
		return
	}
	if a.handleUnauthorizedResponse(w, r, showUnauthorizedJSON) {
		return
	}
	pageData := templateData{
		Page: page,
	}
	var err error
	var responseBytes bytes.Buffer
	func() {
		page.mu.Lock()
		defer page.mu.Unlock()
		page.updateOutdatedWidgets()
		err = pageContentTemplate.Execute(&responseBytes, pageData)
	}()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(responseBytes.Bytes())
}
func (a *Application) addressOfRequest(r *http.Request) string {
	remoteAddrWithoutPort := func() string {
		for i := len(r.RemoteAddr) - 1; i >= 0; i-- {
			if r.RemoteAddr[i] == ':' {
				return r.RemoteAddr[:i]
			}
		}
		return r.RemoteAddr
	}
	if !a.Config.Server.Proxied {
		return remoteAddrWithoutPort()
	}
	// This should probably be configurable or look for multiple headers, not just this one
	forwardedFor := r.Header.Get("X-Forwarded-For")
	if forwardedFor == "" {
		return remoteAddrWithoutPort()
	}
	ips := strings.Split(forwardedFor, ",")
	if len(ips) == 0 || ips[0] == "" {
		return remoteAddrWithoutPort()
	}
	return ips[0]
}
func (a *Application) handleNotFound(w http.ResponseWriter, _ *http.Request) {
	// TODO: add proper not found page
	w.WriteHeader(http.StatusNotFound)
	w.Write([]byte("Page not found"))
}
func (a *Application) handleWidgetRequest(w http.ResponseWriter, r *http.Request) {
	// TODO: this requires a rework of the widget update logic so that rather
	// than locking the entire page we lock individual widgets
	w.WriteHeader(http.StatusNotImplemented)
	// widgetValue := r.PathValue("widget")
	// widgetID, err := strconv.ParseUint(widgetValue, 10, 64)
	// if err != nil {
	// 	a.handleNotFound(w, r)
	// 	return
	// }
	// widget, exists := a.widgetByID[widgetID]
	// if !exists {
	// 	a.handleNotFound(w, r)
	// 	return
	// }
	// widget.handleRequest(w, r)
}
func (a *Application) StaticAssetPath(asset string) string {
	return a.Config.Server.BaseURL + "/static/" + staticFSHash + "/" + asset
}
func (a *Application) VersionedAssetPath(asset string) string {
	return a.Config.Server.BaseURL + asset +
		"?v=" + strconv.FormatInt(a.CreatedAt.Unix(), 10)
}
func (a *Application) server() (func() error, func() error) {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /{$}", a.handlePageRequest)
	mux.HandleFunc("GET /{page}", a.handlePageRequest)
	mux.HandleFunc("GET /api/pages/{page}/content/{$}", a.handlePageContentRequest)
	if !a.Config.Theme.DisablePicker {
		mux.HandleFunc("POST /api/set-theme/{key}", a.handleThemeChangeRequest)
	}
	mux.HandleFunc("/api/widgets/{widget}/{path...}", a.handleWidgetRequest)
	mux.HandleFunc("GET /api/healthz", func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
	if a.RequiresAuth {
		mux.HandleFunc("GET /login", a.handleLoginPageRequest)
		mux.HandleFunc("GET /logout", a.handleLogoutRequest)
		mux.HandleFunc("POST /api/authenticate", a.handleAuthenticationAttempt)
	}
	mux.Handle(
		fmt.Sprintf("GET /static/%s/{path...}", staticFSHash),
		http.StripPrefix(
			"/static/"+staticFSHash,
			fileServerWithCache(http.FS(staticFS), STATIC_ASSETS_CACHE_DURATION),
		),
	)
	assetCacheControlValue := fmt.Sprintf(
		"public, max-age=%d",
		int(STATIC_ASSETS_CACHE_DURATION.Seconds()),
	)
	mux.HandleFunc(fmt.Sprintf("GET /static/%s/css/bundle.css", staticFSHash), func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Cache-Control", assetCacheControlValue)
		w.Header().Add("Content-Type", "text/css; charset=utf-8")
		w.Write(bundledCSSContents)
	})
	mux.HandleFunc("GET /manifest.json", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Cache-Control", assetCacheControlValue)
		w.Header().Add("Content-Type", "application/json")
		w.Write(a.parsedManifest)
	})
	var absAssetsPath string
	if a.Config.Server.AssetsPath != "" {
		absAssetsPath, _ = filepath.Abs(a.Config.Server.AssetsPath)
		assetsFS := fileServerWithCache(http.Dir(a.Config.Server.AssetsPath), 2*time.Hour)
		mux.Handle("/assets/{path...}", http.StripPrefix("/assets/", assetsFS))
	}
	server := http.Server{
		Addr:    fmt.Sprintf("%s:%d", a.Config.Server.Host, a.Config.Server.Port),
		Handler: mux,
	}
	start := func() error {
		log.Printf("Starting server on %s:%d (base-url: \"%s\", assets-path: \"%s\")\n",
			a.Config.Server.Host,
			a.Config.Server.Port,
			a.Config.Server.BaseURL,
			absAssetsPath,
		)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			return err
		}
		return nil
	}
	stop := func() error {
		return server.Close()
	}
	return start, stop
}
</file>

<file path="internal/auth/auth_test.go">
package auth
import (
	"bytes"
	"encoding/base64"
	"testing"
	"time"
)
func TestAuthTokenGenerationAndVerification(t *testing.T) {
	secret, err := MakeAuthSecretKey(AUTH_SECRET_KEY_LENGTH)
	if err != nil {
		t.Fatalf("Failed to generate secret key: %v", err)
	}
	secretBytes, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		t.Fatalf("Failed to decode secret key: %v", err)
	}
	if len(secretBytes) != AUTH_SECRET_KEY_LENGTH {
		t.Fatalf("Secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	now := time.Now()
	username := "admin"
	token, err := generateSessionToken(username, secretBytes, now)
	if err != nil {
		t.Fatalf("Failed to generate session token: %v", err)
	}
	usernameHashBytes, shouldRegen, err := verifySessionToken(token, secretBytes, now)
	if err != nil {
		t.Fatalf("Failed to verify session token: %v", err)
	}
	if shouldRegen {
		t.Fatal("Token should not need to be regenerated immediately after generation")
	}
	computedUsernameHash, err := computeUsernameHash(username, secretBytes)
	if err != nil {
		t.Fatalf("Failed to compute username hash: %v", err)
	}
	if !bytes.Equal(usernameHashBytes, computedUsernameHash) {
		t.Fatal("Username hash does not match the expected value")
	}
	// Test token regeneration
	timeRightAfterRegenPeriod := now.Add(AUTH_TOKEN_VALID_PERIOD - AUTH_TOKEN_REGEN_BEFORE + 2*time.Second)
	_, shouldRegen, err = verifySessionToken(token, secretBytes, timeRightAfterRegenPeriod)
	if err != nil {
		t.Fatalf("Token verification should not fail during regeneration period, err: %v", err)
	}
	if !shouldRegen {
		t.Fatal("Token should have been marked for regeneration")
	}
	// Test token expiration
	_, _, err = verifySessionToken(token, secretBytes, now.Add(AUTH_TOKEN_VALID_PERIOD+2*time.Second))
	if err == nil {
		t.Fatal("Expected token verification to fail after token expiration")
	}
	// Test tampered token
	decodedToken, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		t.Fatalf("Failed to decode token: %v", err)
	}
	// If any of the bytes are off by 1, the token should be considered invalid
	for i := range len(decodedToken) {
		tampered := make([]byte, len(decodedToken))
		copy(tampered, decodedToken)
		tampered[i] += 1
		_, _, err = verifySessionToken(base64.StdEncoding.EncodeToString(tampered), secretBytes, now)
		if err == nil {
			t.Fatalf("Expected token verification to fail for tampered token at index %d", i)
		}
	}
}
</file>

<file path="internal/auth/auth.go">
package auth
import (
	"bytes"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"log"
	mathrand "math/rand/v2"
	"net/http"
	"strconv"
	"strings"
	"time"
	"github.com/limpdev/gander/internal/common"
	"golang.org/x/crypto/bcrypt"
)
const (
	AUTH_SESSION_COOKIE_NAME     = "session_token"
	AUTH_RATE_LIMIT_WINDOW       = 5 * time.Minute
	AUTH_RATE_LIMIT_MAX_ATTEMPTS = 5
)
const (
	AUTH_TOKEN_SECRET_LENGTH  = 32
	AUTH_USERNAME_HASH_LENGTH = 32
	AUTH_SECRET_KEY_LENGTH    = AUTH_TOKEN_SECRET_LENGTH + AUTH_USERNAME_HASH_LENGTH
	AUTH_TIMESTAMP_LENGTH     = 4 // uint32
	AUTH_TOKEN_DATA_LENGTH    = AUTH_USERNAME_HASH_LENGTH + AUTH_TIMESTAMP_LENGTH
)
// How long the token will be valid for
const (
	AUTH_TOKEN_VALID_PERIOD = 14 * 24 * time.Hour // 14 days
	// How long the token has left before it should be regenerated
	AUTH_TOKEN_REGEN_BEFORE = 7 * 24 * time.Hour // 7 days
)
var loginPageTemplate = common.MustParseTemplate("login.html", "document.html", "footer.html")
type doWhenUnauthorized int
const (
	redirectToLogin doWhenUnauthorized = iota
	showUnauthorizedJSON
)
type FailedAuthAttempt struct {
	attempts int
	first    time.Time
}
func generateSessionToken(username string, secret []byte, now time.Time) (string, error) {
	if len(secret) != AUTH_SECRET_KEY_LENGTH {
		return "", fmt.Errorf("secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	usernameHash, err := computeUsernameHash(username, secret)
	if err != nil {
		return "", err
	}
	data := make([]byte, AUTH_TOKEN_DATA_LENGTH)
	copy(data, usernameHash)
	expires := now.Add(AUTH_TOKEN_VALID_PERIOD).Unix()
	binary.LittleEndian.PutUint32(data[AUTH_USERNAME_HASH_LENGTH:], uint32(expires))
	h := hmac.New(sha256.New, secret[0:AUTH_TOKEN_SECRET_LENGTH])
	h.Write(data)
	signature := h.Sum(nil)
	encodedToken := base64.StdEncoding.EncodeToString(append(data, signature...))
	// encodedToken ends up being (hashed username + expiration timestamp + signature) encoded as base64
	return encodedToken, nil
}
func computeUsernameHash(username string, secret []byte) ([]byte, error) {
	if len(secret) != AUTH_SECRET_KEY_LENGTH {
		return nil, fmt.Errorf("secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	h := hmac.New(sha256.New, secret[AUTH_TOKEN_SECRET_LENGTH:])
	h.Write([]byte(username))
	return h.Sum(nil), nil
}
func verifySessionToken(token string, secretBytes []byte, now time.Time) ([]byte, bool, error) {
	tokenBytes, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		return nil, false, err
	}
	if len(tokenBytes) != AUTH_TOKEN_DATA_LENGTH+32 {
		return nil, false, fmt.Errorf("token length is invalid")
	}
	if len(secretBytes) != AUTH_SECRET_KEY_LENGTH {
		return nil, false, fmt.Errorf("secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	usernameHashBytes := tokenBytes[0:AUTH_USERNAME_HASH_LENGTH]
	timestampBytes := tokenBytes[AUTH_USERNAME_HASH_LENGTH : AUTH_USERNAME_HASH_LENGTH+AUTH_TIMESTAMP_LENGTH]
	providedSignatureBytes := tokenBytes[AUTH_TOKEN_DATA_LENGTH:]
	h := hmac.New(sha256.New, secretBytes[0:32])
	h.Write(tokenBytes[0:AUTH_TOKEN_DATA_LENGTH])
	expectedSignatureBytes := h.Sum(nil)
	if !hmac.Equal(expectedSignatureBytes, providedSignatureBytes) {
		return nil, false, fmt.Errorf("signature does not match")
	}
	expiresTimestamp := int64(binary.LittleEndian.Uint32(timestampBytes))
	if now.Unix() > expiresTimestamp {
		return nil, false, fmt.Errorf("token has expired")
	}
	return usernameHashBytes,
		// True if the token should be regenerated
		time.Unix(expiresTimestamp, 0).Add(-AUTH_TOKEN_REGEN_BEFORE).Before(now),
		nil
}
func MakeAuthSecretKey(length int) (string, error) {
	key := make([]byte, length)
	_, err := rand.Read(key)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(key), nil
}
func (a *Application) HandleAuthenticationAttempt(w http.ResponseWriter, r *http.Request) {
	if r.Header.Get("Content-Type") != "application/json" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	waitOnFailure := 1*time.Second - time.Duration(mathrand.IntN(500))*time.Millisecond
	ip := a.addressOfRequest(r)
	a.authAttemptsMu.Lock()
	exceededRateLimit, retryAfter := func() (bool, int) {
		attempt, exists := a.failedAuthAttempts[ip]
		if !exists {
			a.failedAuthAttempts[ip] = &FailedAuthAttempt{
				attempts: 1,
				first:    time.Now(),
			}
			return false, 0
		}
		elapsed := time.Since(attempt.first)
		if elapsed < AUTH_RATE_LIMIT_WINDOW && attempt.attempts >= AUTH_RATE_LIMIT_MAX_ATTEMPTS {
			return true, max(1, int(AUTH_RATE_LIMIT_WINDOW.Seconds()-elapsed.Seconds()))
		}
		attempt.attempts++
		return false, 0
	}()
	if exceededRateLimit {
		a.authAttemptsMu.Unlock()
		time.Sleep(waitOnFailure)
		w.Header().Set("Retry-After", strconv.Itoa(retryAfter))
		w.WriteHeader(http.StatusTooManyRequests)
		return
	} else {
		// Clean up old failed attempts
		for ipOfAttempt := range a.failedAuthAttempts {
			if time.Since(a.failedAuthAttempts[ipOfAttempt].first) > AUTH_RATE_LIMIT_WINDOW {
				delete(a.failedAuthAttempts, ipOfAttempt)
			}
		}
		a.authAttemptsMu.Unlock()
	}
	body, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	var creds struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	err = json.Unmarshal(body, &creds)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	logAuthFailure := func() {
		log.Printf(
			"Failed login attempt for user '%s' from %s",
			creds.Username, ip,
		)
	}
	if len(creds.Username) == 0 || len(creds.Password) == 0 {
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	if len(creds.Username) > 50 || len(creds.Password) > 100 {
		logAuthFailure()
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	u, exists := a.Config.Auth.Users[creds.Username]
	if !exists {
		logAuthFailure()
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	if err := bcrypt.CompareHashAndPassword(u.PasswordHash, []byte(creds.Password)); err != nil {
		logAuthFailure()
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	token, err := generateSessionToken(creds.Username, a.authSecretKey, time.Now())
	if err != nil {
		log.Printf("Could not compute session token during login attempt: %v", err)
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	a.setAuthSessionCookie(w, r, token, time.Now().Add(AUTH_TOKEN_VALID_PERIOD))
	a.authAttemptsMu.Lock()
	delete(a.failedAuthAttempts, ip)
	a.authAttemptsMu.Unlock()
	w.WriteHeader(http.StatusOK)
}
func (a *Application) IsAuthorized(w http.ResponseWriter, r *http.Request) bool {
	if !a.RequiresAuth {
		return true
	}
	token, err := r.Cookie(AUTH_SESSION_COOKIE_NAME)
	if err != nil || token.Value == "" {
		return false
	}
	usernameHash, shouldRegenerate, err := verifySessionToken(token.Value, a.authSecretKey, time.Now())
	if err != nil {
		return false
	}
	username, exists := a.usernameHashToUsername[string(usernameHash)]
	if !exists {
		return false
	}
	_, exists = a.Config.Auth.Users[username]
	if !exists {
		return false
	}
	if shouldRegenerate {
		newToken, err := generateSessionToken(username, a.authSecretKey, time.Now())
		if err != nil {
			log.Printf("Could not compute session token during regeneration: %v", err)
			return false
		}
		a.setAuthSessionCookie(w, r, newToken, time.Now().Add(AUTH_TOKEN_VALID_PERIOD))
	}
	return true
}
// Handles sending the appropriate response for an unauthorized request and returns true if the request was unauthorized
func (a *Application) HandleUnauthorizedResponse(w http.ResponseWriter, r *http.Request, fallback doWhenUnauthorized) bool {
	if a.IsAuthorized(w, r) {
		return false
	}
	switch fallback {
	case redirectToLogin:
		http.Redirect(w, r, a.Config.Server.BaseURL+"/login", http.StatusSeeOther)
	case showUnauthorizedJSON:
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(`{"error": "Unauthorized"}`))
	}
	return true
}
// Maybe this should be a POST request instead?
func (a *Application) HandleLogoutRequest(w http.ResponseWriter, r *http.Request) {
	a.setAuthSessionCookie(w, r, "", time.Now().Add(-1*time.Hour))
	http.Redirect(w, r, a.Config.Server.BaseURL+"/login", http.StatusSeeOther)
}
func (a *Application) setAuthSessionCookie(w http.ResponseWriter, r *http.Request, token string, expires time.Time) {
	http.SetCookie(w, &http.Cookie{
		Name:     AUTH_SESSION_COOKIE_NAME,
		Value:    token,
		Expires:  expires,
		Secure:   strings.ToLower(r.Header.Get("X-Forwarded-Proto")) == "https",
		Path:     a.Config.Server.BaseURL + "/",
		SameSite: http.SameSiteLaxMode,
		HttpOnly: true,
	})
}
func (a *Application) HandleLoginPageRequest(w http.ResponseWriter, r *http.Request) {
	if a.IsAuthorized(w, r) {
		http.Redirect(w, r, a.Config.Server.BaseURL+"/", http.StatusSeeOther)
		return
	}
	data := &templateData{
		App: a,
	}
	a.populateTemplateRequestData(&data.Request, r)
	var responseBytes bytes.Buffer
	err := loginPageTemplate.Execute(&responseBytes, data)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(responseBytes.Bytes())
}
</file>

<file path="internal/web/templates.go">
package web
import (
	"fmt"
	"html/template"
	"math"
	"strconv"
	"golang.org/x/text/language"
	"golang.org/x/text/message"
)
var intl = message.NewPrinter(language.English)
var globalTemplateFunctions = template.FuncMap{
	"formatApproxNumber": formatApproxNumber,
	"formatNumber":       intl.Sprint,
	"safeCSS": func(str string) template.CSS {
		return template.CSS(str)
	},
	"safeURL": func(str string) template.URL {
		return template.URL(str)
	},
	"safeHTML": func(str string) template.HTML {
		return template.HTML(str)
	},
	"absInt": func(i int) int {
		return int(math.Abs(float64(i)))
	},
	"formatPrice": func(price float64) string {
		return intl.Sprintf("%.2f", price)
	},
	"formatPriceWithPrecision": func(precision int, price float64) string {
		return intl.Sprintf("%."+strconv.Itoa(precision)+"f", price)
	},
	"dynamicRelativeTimeAttrs": dynamicRelativeTimeAttrs,
	"formatServerMegabytes": func(mb uint64) template.HTML {
		var value string
		var label string
		if mb < 1_000 {
			value = strconv.FormatUint(mb, 10)
			label = "MB"
		} else if mb < 1_000_000 {
			if mb < 10_000 {
				value = fmt.Sprintf("%.1f", float64(mb)/1_000)
			} else {
				value = strconv.FormatUint(mb/1_000, 10)
			}
			label = "GB"
		} else {
			value = fmt.Sprintf("%.1f", float64(mb)/1_000_000)
			label = "TB"
		}
		return template.HTML(value + ` <span class="color-base size-h5">` + label + `</span>`)
	},
}
func MustParseTemplate(primary string, dependencies ...string) *template.Template {
	t, err := template.New(primary).
		Funcs(globalTemplateFunctions).
		ParseFS(TemplateFS, append([]string{primary}, dependencies...)...)
	if err != nil {
		panic(err)
	}
	return t
}
func formatApproxNumber(count int) string {
	if count < 1_000 {
		return strconv.Itoa(count)
	}
	if count < 10_000 {
		return strconv.FormatFloat(float64(count)/1_000, 'f', 1, 64) + "k"
	}
	if count < 1_000_000 {
		return strconv.Itoa(count/1_000) + "k"
	}
	return strconv.FormatFloat(float64(count)/1_000_000, 'f', 1, 64) + "m"
}
func dynamicRelativeTimeAttrs(t interface{ Unix() int64 }) template.HTMLAttr {
	return template.HTMLAttr(`data-dynamic-relative-time="` + strconv.FormatInt(t.Unix(), 10) + `"`)
}
</file>

<file path="main.go">
package main
import (
	"os"
	"github.com/limpdev/gander/internal/app"
)
func main() {
	os.Exit(app.Main())
}
</file>

<file path="internal/app/main.go">
package app
import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"github.com/limpdev/gander/internal/auth"
	"github.com/limpdev/gander/internal/loader"
	"github.com/limpdev/gander/internal/utils"
	"golang.org/x/crypto/bcrypt"
)
var BuildVersion = "dev"
func Main() int {
	options, err := ParseCliOptions()
	if err != nil {
		fmt.Println(err)
		return 1
	}
	switch options.Intent {
	case IntentVersionPrint:
		fmt.Println(BuildVersion)
	case IntentServe:
		// remove in v0.10.0
		if serveUpdateNoticeIfConfigLocationNotMigrated(options.ConfigPath) {
			return 1
		}
		if err := serveApp(options.ConfigPath); err != nil {
			fmt.Println(err)
			return 1
		}
	case IntentConfigValidate:
		contents, _, err := utils.ParseYAMLIncludes(options.ConfigPath)
		if err != nil {
			fmt.Printf("Could not parse config file: %v\n", err)
			return 1
		}
		if _, err := utils.NewConfigFromYAML(contents); err != nil {
			fmt.Printf("Config file is invalid: %v\n", err)
			return 1
		}
	case IntentConfigPrint:
		contents, _, err := utils.ParseYAMLIncludes(options.ConfigPath)
		if err != nil {
			fmt.Printf("Could not parse config file: %v\n", err)
			return 1
		}
		fmt.Println(string(contents))
	case IntentSensorsPrint:
		return int(IntentSensorsPrint)
	case IntentMountpointInfo:
		return IntentMountpointInfo(options.Args[1])
	case IntentDiagnose:
		return IntentDiagnose()
	case IntentSecretMake:
		key, err := auth.MakeAuthSecretKey(auth.AUTH_SECRET_KEY_LENGTH)
		if err != nil {
			fmt.Printf("Failed to make secret key: %v\n", err)
			return 1
		}
		fmt.Println(key)
	case IntentPasswordHash:
		password := options.Args[1]
		if password == "" {
			fmt.Println("Password cannot be empty")
			return 1
		}
		if len(password) < 6 {
			fmt.Println("Password must be at least 6 characters long")
			return 1
		}
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
		if err != nil {
			fmt.Printf("Failed to hash password: %v\n", err)
			return 1
		}
		fmt.Println(string(hashedPassword))
	}
	return 0
}
func serveApp(configPath string) error {
	// TODO: refactor if this gets any more complex, the current implementation is
	// difficult to reason about due to all of the callbacks and simultaneous operations,
	// use a single goroutine and a channel to initiate synchronous changes to the server
	exitChannel := make(chan struct{})
	hadValidConfigOnStartup := false
	var stopServer func() error
	onChange := func(newContents []byte) {
		if stopServer != nil {
			log.Println("Config file changed, reloading...")
		}
		config, err := newConfigFromYAML(newContents)
		if err != nil {
			log.Printf("Config has errors: %v", err)
			if !hadValidConfigOnStartup {
				close(exitChannel)
			}
			return
		}
		app, err := newApplication(config)
		if err != nil {
			log.Printf("Failed to create application: %v", err)
			if !hadValidConfigOnStartup {
				close(exitChannel)
			}
			return
		}
		if !hadValidConfigOnStartup {
			hadValidConfigOnStartup = true
		}
		if stopServer != nil {
			if err := stopServer(); err != nil {
				log.Printf("Error while trying to stop server: %v", err)
			}
		}
		go func() {
			var startServer func() error
			startServer, stopServer = app.server()
			if err := startServer(); err != nil {
				log.Printf("Failed to start server: %v", err)
			}
		}()
	}
	onErr := func(err error) {
		log.Printf("Error watching config files: %v", err)
	}
	configContents, configIncludes, err := loader.ParseYAMLIncludes(configPath)
	if err != nil {
		return fmt.Errorf("parsing config: %w", err)
	}
	stopWatching, err := loader.ConfigFilesWatcher(configPath, configContents, configIncludes, onChange, onErr)
	if err == nil {
		defer stopWatching()
	} else {
		log.Printf("Error starting file watcher, config file changes will require a manual restart. (%v)", err)
		config, err := loader.NewConfigFromYAML(configContents)
		if err != nil {
			return fmt.Errorf("validating config file: %w", err)
		}
		app, err := loader.NewApplication(config)
		if err != nil {
			return fmt.Errorf("creating application: %w", err)
		}
		startServer, _ := app.server()
		if err := startServer(); err != nil {
			return fmt.Errorf("starting server: %w", err)
		}
	}
	<-exitChannel
	return nil
}
func serveUpdateNoticeIfConfigLocationNotMigrated(configPath string) bool {
	// if !isRunningInsideDockerContainer() {
	// 	return false
	// }
	if _, err := os.Stat(configPath); err == nil {
		return false
	}
	// glance.yml wasn't mounted to begin with or was incorrectly mounted as a directory
	if stat, err := os.Stat("glance.yml"); err != nil || stat.IsDir() {
		return false
	}
	templateFile, _ := auth.TemplateFS.Open("v0.7-update-notice-page.html")
	bodyContents, _ := io.ReadAll(templateFile)
	fmt.Println("!!! WARNING !!!")
	fmt.Println("The default location of glance.yml in the Docker image has changed starting from v0.7.0.")
	fmt.Println("Please see https://github.com/glanceapp/glance/blob/main/docs/v0.7.0-upgrade.md for more information.")
	mux := http.NewServeMux()
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.FS(staticFS))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusServiceUnavailable)
		w.Header().Set("Content-Type", "text/html")
		w.Write([]byte(bodyContents))
	})
	server := http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	server.ListenAndServe()
	return true
}
</file>

</files>
